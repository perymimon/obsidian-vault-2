/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    var __spreadArray4 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dual = exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup5 = function(S) {
      return function() {
        return {
          concat: function(f2, g) {
            return function(a) {
              return S.concat(f2(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup5;
    var getMonoid4 = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid4;
    var getSemiring = function(S) {
      return {
        add: function(f2, g) {
          return function(x) {
            return S.add(f2(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f2, g) {
          return function(x) {
            return S.mul(f2(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f2, g) {
          return function(x) {
            return R.sub(f2(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f2) {
        return f2(a);
      };
    };
    exports.apply = apply;
    function identity4(a) {
      return a;
    }
    exports.identity = identity4;
    exports.unsafeCoerce = identity4;
    function constant2(a) {
      return function() {
        return a;
      };
    }
    exports.constant = constant2;
    exports.constTrue = constant2(true);
    exports.constFalse = constant2(false);
    exports.constNull = constant2(null);
    exports.constUndefined = constant2(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f2) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f2(args[1], args[0]);
        }
        return function(a) {
          return f2(a)(args[0]);
        };
      };
    }
    exports.flip = flip;
    function flow3(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    exports.flow = flow3;
    function tuple2() {
      var t = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t[_i] = arguments[_i];
      }
      return t;
    }
    exports.tuple = tuple2;
    function increment(n) {
      return n + 1;
    }
    exports.increment = increment;
    function decrement(n) {
      return n - 1;
    }
    exports.decrement = decrement;
    function absurd3(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    exports.absurd = absurd3;
    function tupled(f2) {
      return function(a) {
        return f2.apply(void 0, a);
      };
    }
    exports.tupled = tupled;
    function untupled(f2) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f2(a);
      };
    }
    exports.untupled = untupled;
    function pipe5(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.pipe = pipe5;
    exports.hole = absurd3;
    var SK2 = function(_, b) {
      return b;
    };
    exports.SK = SK2;
    function not2(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    exports.not = not2;
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first2, second) {
          return flow3(first2, second);
        },
        empty: identity4
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
    var dual2 = function(arity, body) {
      var isDataFirst = typeof arity === "number" ? function(args) {
        return args.length >= arity;
      } : arity;
      return function() {
        var args = Array.from(arguments);
        if (isDataFirst(arguments)) {
          return body.apply(this, args);
        }
        return function(self) {
          return body.apply(void 0, __spreadArray4([self], args, false));
        };
      };
    };
    exports.dual = dual2;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ModalFormPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian19 = require("obsidian");

// src/exampleModalDefinition.ts
var exampleModalDefinition = {
  title: "Example form",
  name: "example-form",
  version: "1",
  fields: [
    {
      name: "Name",
      description: "It is named how?",
      isRequired: true,
      input: { type: "text" }
    },
    {
      name: "age",
      label: "Age",
      description: "How old",
      isRequired: true,
      input: { type: "number" }
    },
    {
      name: "dateOfBirth",
      label: "Date of Birth",
      description: "When were you born?",
      input: { type: "date" }
    },
    {
      name: "timeOfDay",
      label: "Time of day",
      description: "The time you can do this",
      input: { type: "time" }
    },
    {
      name: "is_family",
      label: "Is family",
      description: "If it is part of the family",
      input: { type: "toggle" }
    },
    {
      name: "favorite_book",
      label: "Favorite book",
      description: "Pick one",
      input: { type: "note", folder: "Books" }
    },
    {
      name: "folder",
      label: "The destination folder",
      description: "It offers auto-completion to existing folders",
      input: { type: "folder" }
    },
    {
      name: "multi_example",
      label: "Multi select folder",
      description: "Allows to pick many notes from a folder",
      input: { type: "multiselect", source: "notes", folder: "Books" }
    },
    {
      name: "multi_example_2",
      label: "Multi select fixed",
      description: "Allows to pick many notes from a fixed list",
      input: {
        type: "multiselect",
        source: "fixed",
        multi_select_options: [
          "Android",
          "iOS",
          "Windows",
          "MacOS",
          "Linux",
          "Solaris",
          "MS2"
        ]
      }
    },
    {
      name: "multi_select_dataview",
      label: "Multi select dataview",
      description: "Allows to pick several values from a dv query",
      input: {
        type: "multiselect",
        source: "dataview",
        query: 'dv.pages("#person").map(p => p.file.name)'
      }
    },
    {
      name: "best_fried",
      label: "Best friend",
      description: "Pick one",
      input: {
        type: "select",
        source: "notes",
        folder: "People"
      }
    },
    {
      name: "dataview_example",
      label: "Dataview example",
      description: "Only people matching the dataview query will be shown",
      input: {
        type: "dataview",
        query: 'dv.pages("#person").filter(p => p.age < 30).map(p => p.file.name)'
      }
    },
    {
      name: "friendship_level",
      label: "Friendship level",
      description: "How good friends are you?",
      input: {
        type: "slider",
        min: 0,
        max: 10
      }
    },
    {
      name: "favorite_meal",
      label: "Favorite meal",
      description: "Pick one option",
      input: {
        type: "select",
        source: "fixed",
        options: [
          { value: "pizza", label: "\u{1F355} Pizza" },
          { value: "pasta", label: "\u{1F35D} Pasta" },
          { value: "burger", label: "\u{1F354} Burger" },
          { value: "salad", label: "\u{1F957} Salad" },
          { value: "steak", label: "\u{1F969} Steak" },
          { value: "sushi", label: "\u{1F363} Sushi" },
          { value: "ramen", label: "\u{1F35C} Ramen" },
          { value: "tacos", label: "\u{1F32E} Tacos" },
          { value: "fish", label: "\u{1F41F} Fish" },
          { value: "chicken", label: "\u{1F357} Chicken" }
        ]
      }
    },
    {
      name: "some notes",
      label: "Multi line notes",
      description: "Put your thouhts here",
      input: {
        type: "textarea"
      }
    },
    {
      name: "Tags",
      description: "Tags input example",
      input: { type: "tag" }
    }
  ]
};

// src/ModalFormSettingTab.ts
var import_obsidian = require("obsidian");

// node_modules/valibot/dist/index.js
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
var BrandSymbol = Symbol("brand");
function coerce(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return schema._parse(action(input), info);
    }
  };
}
function getIssues(issues) {
  return { issues };
}
function getOutput(output) {
  return { output };
}
function getIssue(info, issue) {
  return {
    reason: info == null ? void 0 : info.reason,
    validation: issue.validation,
    origin: (info == null ? void 0 : info.origin) || "value",
    message: issue.message,
    input: issue.input,
    path: issue.path,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info == null ? void 0 : info.origin,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function executePipe(input, pipe5, parseInfo, reason) {
  if (!pipe5 || !pipe5.length || (parseInfo == null ? void 0 : parseInfo.skipPipe)) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe5) {
    const result = action(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
function getDefaultArgs(arg1, arg2) {
  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
}
function getErrorMessage(error2) {
  return typeof error2 === "function" ? error2() : error2;
}
function getPipeIssues(validation, error2, input) {
  return getIssues([
    {
      validation,
      message: getErrorMessage(error2),
      input
    }
  ]);
}
function getSchemaIssues(info, reason, validation, error2, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: (info == null ? void 0 : info.origin) || "value",
        message: getErrorMessage(error2),
        input,
        issues,
        abortEarly: info == null ? void 0 : info.abortEarly,
        abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
        skipPipe: info == null ? void 0 : info.skipPipe
      }
    ]
  };
}
function is(schema, input) {
  return !schema._parse(input, { abortEarly: true }).issues;
}
function array(item2, arg2, arg3) {
  const [error2, pipe5] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item: item2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(
          info,
          "type",
          "array",
          error2 || "Invalid type",
          input
        );
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = item2._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, pipe5, info, "array");
    }
  };
}
function boolean(arg1, arg2) {
  const [error2, pipe5] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "boolean") {
        return getSchemaIssues(
          info,
          "type",
          "boolean",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe5, info, "boolean");
    }
  };
}
function enumType(enumValue, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getSchemaIssues(
          info,
          "type",
          "enum",
          error2 || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function literal(literal2, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== literal2) {
        return getSchemaIssues(
          info,
          "type",
          "literal",
          error2 || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function number(arg1, arg2) {
  const [error2, pipe5] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "number" || Number.isNaN(input)) {
        return getSchemaIssues(
          info,
          "type",
          "number",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe5, info, "number");
    }
  };
}
function object(object2, arg2, arg3) {
  const [error2, pipe5] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(
          info,
          "type",
          "object",
          error2 || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      for (const [key, schema] of cachedEntries) {
        const value2 = input[key];
        const result = schema._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else if (result.output !== void 0 || key in input) {
          output[key] = result.output;
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe5,
        info,
        "object"
      );
    }
  };
}
function optional(wrapped, default_) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * The default value.
     */
    get default() {
      return typeof default_ === "function" ? default_() : default_;
    },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const value2 = input === void 0 ? this.default : input;
      if (value2 === void 0) {
        return getOutput(value2);
      }
      return wrapped._parse(value2, info);
    }
  };
}
function string(arg1, arg2) {
  const [error2, pipe5] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(
          info,
          "type",
          "string",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe5, info, "string");
    }
  };
}
function union(union22, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union22,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      let issues;
      let output;
      for (const schema of union22) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(
        info,
        "type",
        "union",
        error2 || "Invalid type",
        input,
        issues
      );
    }
  };
}
function unknown(pipe5 = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe5, info, "unknown");
    }
  };
}
function merge(schemas, arg2, arg3) {
  const [error2, pipe5] = getDefaultArgs(arg2, arg3);
  return object(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error2,
    pipe5
  );
}
function parse(schema, input, info) {
  const result = schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}
function passthrough(schema) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues ? getOutput({ ...input, ...result.output }) : result;
    }
  };
}
function safeParse(schema, input, info) {
  const result = schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}
function toTrimmed() {
  return (input) => getOutput(input.trim());
}
function minLength(requirement, error2) {
  return (input) => input.length < requirement ? getPipeIssues("min_length", error2 || "Invalid length", input) : getOutput(input);
}

// node_modules/fp-ts/es6/function.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function identity(a) {
  return a;
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self) {
      return body.apply(void 0, __spreadArray([self], args, false));
    };
  };
};

// node_modules/fp-ts/es6/internal.js
var isSome = function(fa) {
  return fa._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a) {
  return { _tag: "Some", value: a };
};
var isLeft = function(ma) {
  return ma._tag === "Left";
};
var isRight = function(ma) {
  return ma._tag === "Right";
};
var left = function(e) {
  return { _tag: "Left", left: e };
};
var right = function(a) {
  return { _tag: "Right", right: a };
};
var singleton = function(a) {
  return [a];
};
var isNonEmpty = function(as4) {
  return as4.length > 0;
};
var has = Object.prototype.hasOwnProperty;

// node_modules/fp-ts/es6/Functor.js
function as(F) {
  return function(self, b) {
    return F.map(self, function() {
      return b;
    });
  };
}
function asUnit(F) {
  var asM = as(F);
  return function(self) {
    return asM(self, void 0);
  };
}

// node_modules/fp-ts/es6/Chain.js
function tap(M) {
  return function(first2, f2) {
    return M.chain(first2, function(a) {
      return M.map(f2(a), function() {
        return a;
      });
    });
  };
}

// node_modules/fp-ts/es6/ChainRec.js
var tailRec = function(startWith, f2) {
  var ab = f2(startWith);
  while (ab._tag === "Left") {
    ab = f2(ab.left);
  }
  return ab.right;
};

// node_modules/fp-ts/es6/FromEither.js
function fromEitherK(F) {
  return function(f2) {
    return flow(f2, F.fromEither);
  };
}
function tapEither(F, M) {
  var fromEither2 = fromEitherK(F);
  var tapM = tap(M);
  return function(self, f2) {
    return tapM(self, fromEither2(f2));
  };
}

// node_modules/fp-ts/es6/Separated.js
var separated = function(left3, right3) {
  return { left: left3, right: right3 };
};

// node_modules/fp-ts/es6/Either.js
var left2 = left;
var right2 = right;
var flatMap = /* @__PURE__ */ dual(2, function(ma, f2) {
  return isLeft2(ma) ? ma : f2(ma.right);
});
var _map = function(fa, f2) {
  return pipe(fa, map(f2));
};
var _ap = function(fab, fa) {
  return pipe(fab, ap(fa));
};
var URI = "Either";
var map = function(f2) {
  return function(fa) {
    return isLeft2(fa) ? fa : right2(f2(fa.right));
  };
};
var Functor = {
  URI,
  map: _map
};
var as2 = dual(2, as(Functor));
var asUnit2 = asUnit(Functor);
var apW = function(fa) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right2(fab.right(fa.right));
  };
};
var ap = apW;
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var bimap = function(f2, g) {
  return function(fa) {
    return isLeft2(fa) ? left2(f2(fa.left)) : right2(g(fa.right));
  };
};
var mapLeft = function(f2) {
  return function(fa) {
    return isLeft2(fa) ? left2(f2(fa.left)) : fa;
  };
};
var FromEither = {
  URI,
  fromEither: identity
};
var isLeft2 = isLeft;
var isRight2 = isRight;
var matchW = function(onLeft, onRight) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
  };
};
var match = matchW;
var fold = match;
var getOrElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma.right;
  };
};
var getOrElse = getOrElseW;
var tap2 = /* @__PURE__ */ dual(2, tap(Chain));
var _FromEither = {
  fromEither: FromEither.fromEither
};
var orElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma;
  };
};
var orElse = orElseW;
var fromNullable = function(e) {
  return function(a) {
    return a == null ? left2(e) : right2(a);
  };
};
var tryCatch = function(f2, onThrow) {
  try {
    return right2(f2());
  } catch (e) {
    return left2(onThrow(e));
  }
};
var tryCatchK = function(f2, onThrow) {
  return function() {
    var a = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a[_i] = arguments[_i];
    }
    return tryCatch(function() {
      return f2.apply(void 0, a);
    }, onThrow);
  };
};
var chainW = flatMap;
var chain = flatMap;

// src/std/index.ts
var import_function6 = __toESM(require_function());

// node_modules/fp-ts/es6/Magma.js
var concatAll = function(M) {
  return function(startWith) {
    return function(as4) {
      return as4.reduce(function(a, acc) {
        return M.concat(a, acc);
      }, startWith);
    };
  };
};

// node_modules/fp-ts/es6/Semigroup.js
var constant = function(a) {
  return {
    concat: function() {
      return a;
    }
  };
};
var struct = function(semigroups) {
  return {
    concat: function(first2, second) {
      var r = {};
      for (var k in semigroups) {
        if (has.call(semigroups, k)) {
          r[k] = semigroups[k].concat(first2[k], second[k]);
        }
      }
      return r;
    }
  };
};
var first = function() {
  return { concat: identity };
};
var last = function() {
  return { concat: function(_, y) {
    return y;
  } };
};
var concatAll2 = concatAll;
var semigroupVoid = constant(void 0);
var semigroupAll = {
  concat: function(x, y) {
    return x && y;
  }
};
var semigroupAny = {
  concat: function(x, y) {
    return x || y;
  }
};
var semigroupString = {
  concat: function(x, y) {
    return x + y;
  }
};
var semigroupSum = {
  concat: function(x, y) {
    return x + y;
  }
};
var semigroupProduct = {
  concat: function(x, y) {
    return x * y;
  }
};

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty2 = isNonEmpty;
var isOutOfBound = function(i, as4) {
  return i < 0 || i >= as4.length;
};
var appendW = function(end) {
  return function(init4) {
    return __spreadArray2(__spreadArray2([], init4, true), [end], false);
  };
};
var append = appendW;
var of = singleton;

// node_modules/fp-ts/es6/NonEmptyArray.js
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty3 = function(as4) {
  return as4.length > 0;
};
var prependW = function(head5) {
  return function(tail4) {
    return __spreadArray3([head5], tail4, true);
  };
};
var prepend = prependW;
var appendW2 = function(end) {
  return function(init4) {
    return __spreadArray3(__spreadArray3([], init4, true), [end], false);
  };
};
var append2 = appendW2;
var fromArray = function(as4) {
  return isNonEmpty3(as4) ? some(as4) : none;
};
var of2 = function(a) {
  return [a];
};

// node_modules/fp-ts/es6/ReadonlyArray.js
var append3 = append;
var isOutOfBound2 = isOutOfBound;
function lookup(i, as4) {
  return as4 === void 0 ? function(as5) {
    return lookup(i, as5);
  } : isOutOfBound2(i, as4) ? none : some(as4[i]);
}
function findFirst(predicate) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      if (predicate(as4[i])) {
        return some(as4[i]);
      }
    }
    return none;
  };
}
var findFirstMap = function(f2) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      var out = f2(as4[i]);
      if (isSome(out)) {
        return out;
      }
    }
    return none;
  };
};
var foldMapWithIndex = function(M) {
  return function(f2) {
    return function(fa) {
      return fa.reduce(function(b, a, i) {
        return M.concat(b, f2(i, a));
      }, M.empty);
    };
  };
};
var reduce = function(b, f2) {
  return reduceWithIndex(b, function(_, b2, a) {
    return f2(b2, a);
  });
};
var foldMap = function(M) {
  var foldMapWithIndexM = foldMapWithIndex(M);
  return function(f2) {
    return foldMapWithIndexM(function(_, a) {
      return f2(a);
    });
  };
};
var reduceWithIndex = function(b, f2) {
  return function(fa) {
    var len = fa.length;
    var out = b;
    for (var i = 0; i < len; i++) {
      out = f2(i, out, fa[i]);
    }
    return out;
  };
};
var reduceRight = function(b, f2) {
  return reduceRightWithIndex(b, function(_, a, b2) {
    return f2(a, b2);
  });
};
var reduceRightWithIndex = function(b, f2) {
  return function(fa) {
    return fa.reduceRight(function(b2, a, i) {
      return f2(i, a, b2);
    }, b);
  };
};

// node_modules/fp-ts/es6/Array.js
var prepend3 = prepend;
var append4 = append2;
var lookup2 = lookup;
function findFirst2(predicate) {
  return findFirst(predicate);
}
var findFirstMap2 = findFirstMap;
var _reduce = function(fa, b, f2) {
  return pipe(fa, reduce2(b, f2));
};
var _foldMap = function(M) {
  var foldMapM = foldMap2(M);
  return function(fa, f2) {
    return pipe(fa, foldMapM(f2));
  };
};
var _reduceRight = function(fa, b, f2) {
  return pipe(fa, reduceRight2(b, f2));
};
var map2 = function(f2) {
  return function(fa) {
    return fa.map(function(a) {
      return f2(a);
    });
  };
};
var filterMapWithIndex = function(f2) {
  return function(fa) {
    var out = [];
    for (var i = 0; i < fa.length; i++) {
      var optionB = f2(i, fa[i]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap = function(f2) {
  return filterMapWithIndex(function(_, a) {
    return f2(a);
  });
};
var compact = /* @__PURE__ */ filterMap(identity);
var separate = function(fa) {
  var left3 = [];
  var right3 = [];
  for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
    var e = fa_1[_i];
    if (e._tag === "Left") {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return separated(left3, right3);
};
var filter = function(predicate) {
  return function(as4) {
    return as4.filter(predicate);
  };
};
var partition = function(predicate) {
  return partitionWithIndex(function(_, a) {
    return predicate(a);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as4) {
    var left3 = [];
    var right3 = [];
    for (var i = 0; i < as4.length; i++) {
      var b = as4[i];
      if (predicateWithIndex(i, b)) {
        right3.push(b);
      } else {
        left3.push(b);
      }
    }
    return separated(left3, right3);
  };
};
var partitionMap = function(f2) {
  return partitionMapWithIndex(function(_, a) {
    return f2(a);
  });
};
var partitionMapWithIndex = function(f2) {
  return function(fa) {
    var left3 = [];
    var right3 = [];
    for (var i = 0; i < fa.length; i++) {
      var e = f2(i, fa[i]);
      if (e._tag === "Left") {
        left3.push(e.left);
      } else {
        right3.push(e.right);
      }
    }
    return separated(left3, right3);
  };
};
var foldMap2 = foldMap;
var reduce2 = reduce;
var reduceRight2 = reduceRight;
var URI2 = "Array";
var getSemigroup2 = function() {
  return {
    concat: function(first2, second) {
      return first2.concat(second);
    }
  };
};
var getMonoid = function() {
  return {
    concat: getSemigroup2().concat,
    empty: []
  };
};
var Foldable = {
  URI: URI2,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight
};
var some2 = function(predicate) {
  return function(as4) {
    return as4.some(predicate);
  };
};

// node_modules/fp-ts/es6/Predicate.js
var not = function(predicate) {
  return function(a) {
    return !predicate(a);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some3 = some;
var getRight = function(ma) {
  return ma._tag === "Left" ? none2 : some3(ma.right);
};
var _map2 = function(fa, f2) {
  return pipe(fa, map3(f2));
};
var _ap2 = function(fab, fa) {
  return pipe(fab, ap2(fa));
};
var URI3 = "Option";
var map3 = function(f2) {
  return function(fa) {
    return isNone2(fa) ? none2 : some3(f2(fa.value));
  };
};
var Functor2 = {
  URI: URI3,
  map: _map2
};
var as3 = dual(2, as(Functor2));
var asUnit3 = asUnit(Functor2);
var ap2 = function(fa) {
  return function(fab) {
    return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some3(fab.value(fa.value));
  };
};
var flatMap2 = /* @__PURE__ */ dual(2, function(ma, f2) {
  return isNone2(ma) ? none2 : f2(ma.value);
});
var Chain2 = {
  URI: URI3,
  map: _map2,
  ap: _ap2,
  chain: flatMap2
};
var orElse2 = dual(2, function(self, that) {
  return isNone2(self) ? that() : self;
});
var fromEither = getRight;
var FromEither2 = {
  URI: URI3,
  fromEither
};
var isNone2 = function(fa) {
  return fa._tag === "None";
};
var matchW2 = function(onNone, onSome) {
  return function(ma) {
    return isNone2(ma) ? onNone() : onSome(ma.value);
  };
};
var match2 = matchW2;
var fold2 = match2;
var getOrElseW2 = function(onNone) {
  return function(ma) {
    return isNone2(ma) ? onNone() : ma.value;
  };
};
var getOrElse2 = getOrElseW2;
var tap3 = /* @__PURE__ */ dual(2, tap(Chain2));
var tapEither2 = /* @__PURE__ */ dual(2, tapEither(FromEither2, Chain2));
var fromNullable2 = function(a) {
  return a == null ? none2 : some3(a);
};
var chain2 = flatMap2;

// src/std/index.ts
var flow2 = import_function6.flow;
var pipe2 = import_function6.pipe;
var A = {
  partitionMap,
  partition,
  compact,
  findFirst: findFirst2,
  findFirstMap: findFirstMap2,
  map: map2,
  filter,
  filterMap
};
var E = {
  isLeft: isLeft2,
  isRight: isRight2,
  left: left2,
  right: right2,
  tryCatchK,
  tryCatch,
  getOrElse,
  map,
  mapLeft,
  bimap,
  flatMap,
  fromNullable
};
var O = {
  map: map3,
  getOrElse: getOrElse2,
  some: some3,
  none: none2,
  fold: fold2,
  fromNullable: fromNullable2
};
var parse2 = tryCatchK(parse, (e) => e);
function parseC(schema, options) {
  return (input) => parse2(schema, input, options);
}
var _EFunSemigroup = class {
  concat(f2, g) {
    return (i) => {
      const fRes = f2(i);
      if (isRight2(fRes))
        return fRes;
      return g(i);
    };
  }
};
var EFunSemigroup = new _EFunSemigroup();
function trySchemas(schemas, options) {
  const [first2, ...rest] = schemas;
  return pipe2(
    rest,
    A.map((schema) => parseC(schema, options)),
    concatAll2(EFunSemigroup)(parseC(first2, options))
  );
}
function throttle(fn, ms = 100) {
  let lastCall = 0;
  return function(...args) {
    const now2 = Date.now();
    if (now2 - lastCall < ms) {
      lastCall = now2;
      return;
    }
    lastCall = now2;
    return fn(...args);
  };
}

// src/core/settings.ts
var OpenPositionSchema = enumType(["left", "right", "mainView"]);
function isValidOpenPosition(position) {
  return is(OpenPositionSchema, position);
}
var ModalFormSettingsSchema = object({
  editorPosition: optional(OpenPositionSchema, "right"),
  formDefinitions: array(unknown())
});
function getDefaultSettings() {
  return { editorPosition: "right", formDefinitions: [] };
}
var NullSettingsError = class {
  constructor() {
    this._tag = "NullSettingsError";
  }
};
function parseSettings(maybeSettings) {
  return pipe2(
    maybeSettings,
    fromNullable(new NullSettingsError()),
    chainW((s) => parse2(ModalFormSettingsSchema, { ...getDefaultSettings(), ...s }))
  );
}

// src/ModalFormSettingTab.ts
var ModalFormSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("a", { text: "Modal Form documentation", cls: "nav-link", href: "https://github.com/danielo515/obsidian-modal-form" });
    const settings2 = await plugin.getSettings();
    new import_obsidian.Setting(containerEl).setName("Editor position").setDesc("Where the form editor will be opened. In mobile it will always be main view.").addDropdown((component) => {
      component.addOptions({
        left: "Left",
        right: "Right",
        mainView: "Main View"
      }).setValue(settings2.editorPosition).onChange(async (value) => {
        if (isValidOpenPosition(value)) {
          await this.plugin.setEditorPosition(value);
        }
      });
    });
  }
};

// src/core/findInputDefinitionSchema.ts
function stringifyIssues(error2) {
  return error2.issues.map((issue) => {
    var _a;
    return `${(_a = issue.path) == null ? void 0 : _a.map((i) => i.key)}: ${issue.message} got ${issue.input}`;
  });
}
var InvalidInputTypeError = class {
  constructor(field, inputType) {
    this.field = field;
    this.inputType = inputType;
    this.path = "input.type";
  }
  toString() {
    return `InvalidInputTypeError: ${this.getFieldErrors()[0]}`;
  }
  getFieldErrors() {
    return [`"input.type" is invalid, got: ${JSON.stringify(this.inputType)}`];
  }
};
InvalidInputTypeError._tag = "InvalidInputTypeError";
var InvalidInputError = class {
  constructor(field, error2) {
    this.field = field;
    this.error = error2;
    var _a, _b;
    this.path = (_b = (_a = error2.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidInputError: ${stringifyIssues(this.error).join(", ")}`;
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
};
InvalidInputError._tag = "InvalidInputError";
var _InvalidFieldError = class {
  constructor(field, error2) {
    this.field = field;
    this.error = error2;
    var _a, _b;
    this.path = (_b = (_a = error2.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidFieldError: ${stringifyIssues(this.error).join(", ")}`;
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
  static of(field) {
    return (error2) => new _InvalidFieldError(field, error2);
  }
};
var InvalidFieldError = _InvalidFieldError;
InvalidFieldError._tag = "InvalidFieldError";
function isValidInputType(input) {
  return "string" === typeof input && input in InputTypeToParserMap;
}
function findInputDefinitionSchema(fieldDefinition) {
  return pipe2(
    parse2(FieldMinimalSchema, fieldDefinition),
    mapLeft(InvalidFieldError.of(fieldDefinition)),
    chainW((field) => {
      const type = field.input.type;
      if (isValidInputType(type))
        return right2([field, InputTypeToParserMap[type]]);
      else
        return left2(new InvalidInputTypeError(field, type));
    })
  );
}
function findFieldErrors(fields) {
  return pipe2(
    fields,
    A.map((fieldUnparsed) => {
      return pipe2(
        findInputDefinitionSchema(fieldUnparsed),
        chainW(
          ([field, parser]) => pipe2(
            parser(field.input),
            bimap(
              (error2) => new InvalidInputError(field, error2),
              () => field
            )
          )
        )
      );
    })
    // A.partition(E.isLeft),
    // Separated.right,
  );
}

// src/core/template/templateSchema.ts
var TemplateTextSchema = object({
  _tag: literal("text"),
  value: string()
});
var TemplateVariableSchema = object({
  _tag: literal("variable"),
  value: string()
});
var FrontmatterCommandSchema = object({
  _tag: literal("frontmatter-command"),
  pick: array(string()),
  omit: array(string())
});
var ParsedTemplateSchema = array(union([TemplateTextSchema, TemplateVariableSchema, FrontmatterCommandSchema]));

// src/core/formDefinitionSchema.ts
function nonEmptyString(name) {
  return string(`${name} should be a string`, [
    toTrimmed(),
    minLength(1, `${name} should not be empty`)
  ]);
}
var InputBasicTypeSchema = enumType([
  "text",
  "number",
  "date",
  "time",
  "datetime",
  "textarea",
  "toggle",
  "email",
  "tel"
]);
var SelectFromNotesSchema = object({
  type: literal("select"),
  source: literal("notes"),
  folder: nonEmptyString("folder name")
});
var InputTagSchema = object({
  type: literal("tag"),
  exclude: optional(string())
  // This should be a regex string
});
var InputSliderSchema = object({
  type: literal("slider"),
  min: number(),
  max: number()
});
var InputNoteFromFolderSchema = object({
  type: literal("note"),
  folder: nonEmptyString("folder name")
});
var InputFolderSchema = object({
  type: literal("folder")
  // TODO: allow exclude option
});
var InputDataviewSourceSchema = object({
  type: literal("dataview"),
  query: nonEmptyString("dataview query")
});
var InputBasicSchema = object({ type: InputBasicTypeSchema });
var InputSelectFixedSchema = object({
  type: literal("select"),
  source: literal("fixed"),
  options: array(
    object({
      value: string([toTrimmed()]),
      label: string()
    })
  )
});
var MultiSelectNotesSchema = object({
  type: literal("multiselect"),
  source: literal("notes"),
  folder: nonEmptyString("multi select source folder")
});
var MultiSelectFixedSchema = object({
  type: literal("multiselect"),
  source: literal("fixed"),
  multi_select_options: array(string())
});
var MultiSelectQuerySchema = object({
  type: literal("multiselect"),
  source: literal("dataview"),
  query: nonEmptyString("dataview query")
});
var MultiselectSchema = union([
  MultiSelectNotesSchema,
  MultiSelectFixedSchema,
  MultiSelectQuerySchema
]);
var InputTypeSchema = union([
  InputBasicSchema,
  InputNoteFromFolderSchema,
  InputFolderSchema,
  InputSliderSchema,
  InputTagSchema,
  SelectFromNotesSchema,
  InputDataviewSourceSchema,
  InputSelectFixedSchema,
  MultiselectSchema
]);
var InputTypeToParserMap = {
  number: parseC(InputBasicSchema),
  text: parseC(InputBasicSchema),
  email: parseC(InputBasicSchema),
  tel: parseC(InputBasicSchema),
  date: parseC(InputBasicSchema),
  time: parseC(InputBasicSchema),
  datetime: parseC(InputBasicSchema),
  textarea: parseC(InputBasicSchema),
  toggle: parseC(InputBasicSchema),
  note: parseC(InputNoteFromFolderSchema),
  folder: parseC(InputFolderSchema),
  slider: parseC(InputSliderSchema),
  tag: parseC(InputTagSchema),
  select: trySchemas([SelectFromNotesSchema, InputSelectFixedSchema]),
  dataview: parseC(InputDataviewSourceSchema),
  multiselect: parseC(MultiselectSchema)
};
var FieldDefinitionSchema = object({
  name: nonEmptyString("field name"),
  label: optional(string()),
  description: string(),
  isRequired: optional(boolean()),
  input: InputTypeSchema
});
var FieldMinimalSchema = passthrough(
  merge([
    FieldDefinitionSchema,
    object({ input: passthrough(object({ type: string() })) })
  ])
);
var FieldListSchema = array(FieldDefinitionSchema);
var FormDefinitionBasicSchema = object({
  title: nonEmptyString("form title"),
  name: nonEmptyString("form name"),
  customClassname: optional(string()),
  fields: array(unknown())
});
var FormDefinitionV1Schema = merge([
  FormDefinitionBasicSchema,
  object({
    version: literal("1"),
    fields: FieldListSchema,
    template: optional(
      object({
        createCommand: boolean(),
        parsedTemplate: ParsedTemplateSchema
      })
    )
  })
]);
var FormDefinitionLatestSchema = FormDefinitionV1Schema;
var MigrationError = class {
  constructor(form, error2) {
    this.form = form;
    this.error = error2;
    this.name = form.name;
  }
  toString() {
    return `MigrationError: 
            ${this.error.message}
            ${this.error.issues.map((issue) => issue.message).join(", ")}`;
  }
  // This allows to store the error in the settings, along with the rest of the forms and
  // have save all the data in one go transparently.
  // This is required so we don't lose the form, even if it is invalid
  toJSON() {
    return this.form;
  }
  get fieldErrors() {
    return findFieldErrors(this.form.fields);
  }
};
MigrationError._tag = "MigrationError";
var InvalidData = class {
  constructor(data, error2) {
    this.data = data;
    this.error = error2;
  }
  toString() {
    return `InvalidData: ${this.error.issues.map((issue) => issue.message).join(", ")}`;
  }
};
InvalidData._tag = "InvalidData";
function fromV0toV1(data) {
  return pipe2(
    parse2(FormDefinitionV1Schema, { ...data, version: "1" }),
    getOrElseW((error2) => new MigrationError(data, error2))
  );
}
function migrateToLatest(data) {
  return pipe2(
    // first try a quick one with the latest schema
    parse2(FormDefinitionLatestSchema, data, { abortEarly: true }),
    orElse(
      () => pipe2(
        parse2(FormDefinitionBasicSchema, data),
        mapLeft((error2) => new InvalidData(data, error2)),
        map(fromV0toV1)
      )
    )
  );
}
function formNeedsMigration(data) {
  return !is(FormDefinitionLatestSchema, data);
}

// src/utils/ModalFormError.ts
var ModalFormError = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};

// src/FormModal.ts
var import_obsidian9 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append5(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append5(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty2() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind2(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init3(component, options, instance14, create_fragment14, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance14 ? instance14(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment14 ? create_fragment14($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/suggesters/MultiSuggest.ts
var import_obsidian2 = require("obsidian");
var MultiSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(inputEl, content, onSelectCb, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    return [...this.content].filter(
      (content) => content.toLocaleLowerCase().contains(lowerCaseInputStr)
    );
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = "";
    this.close();
    this.inputEl.focus();
  }
};

// src/views/components/MultiSelect.svelte
function add_css(target) {
  append_styles(target, "svelte-168eg05", ".multi-select-root.svelte-168eg05.svelte-168eg05{display:flex;flex-direction:column;gap:0.5rem;flex:1;--button-size:1.5rem}.badge.svelte-168eg05.svelte-168eg05{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width);display:flex;align-items:center;background-color:var(--pill-background);border:var(--pill-border-width) solid var(--pill-border-color);border-radius:var(--pill-radius);color:var(--pill-color);cursor:var(--cursor);font-weight:var(--pill-weight);padding-top:var(--pill-padding-y);padding-bottom:var(--pill-padding-y);padding-left:var(--pill-padding-x);padding-right:var(--pill-padding-x);line-height:1;max-width:100%;gap:var(--size-4-2);justify-content:center;align-items:center}.hidden.svelte-168eg05.svelte-168eg05{visibility:hidden}.hidden.svelte-168eg05 span.svelte-168eg05{height:var(--button-size)}.badge.svelte-168eg05 span.svelte-168eg05{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:1rem}.badges.svelte-168eg05.svelte-168eg05{display:flex;flex-wrap:wrap;gap:8px;min-height:2rem;padding:0.5rem 0 0 0}button.svelte-168eg05.svelte-168eg05{background:none;border:none;color:inherit;font:inherit;line-height:inherit;padding:0;-webkit-appearance:none;-moz-appearance:none;-o-appearance:none;appearance:none;box-shadow:none;border:none;cursor:pointer;height:var(--button-size);width:var(--button-size)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let span;
  let t_value = (
    /*error*/
    ctx[14] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "invalid");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$errors*/
      4 && t_value !== (t_value = /*error*/
      ctx2[14] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="svelte-168eg05">Nothing selected</span> `;
      attr(div, "class", "badge hidden svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0_value = (
    /*value*/
    ctx[11] + ""
  );
  let t0;
  let t1;
  let button;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[9](
        /*value*/
        ctx[11]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
      t2 = space();
      attr(span, "class", "svelte-168eg05");
      attr(button, "class", "svelte-168eg05");
      attr(div, "class", "badge svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, span);
      append5(span, t0);
      append5(div, t1);
      append5(div, button);
      append5(div, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$values*/
      8 && t0_value !== (t0_value = /*value*/
      ctx[11] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div1;
  let input;
  let createInput_action;
  let t0;
  let t1;
  let div0;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*$errors*/
    ctx[2]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*$values*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let each1_else = null;
  if (!each_value.length) {
    each1_else = create_else_block(ctx);
  }
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (each1_else) {
        each1_else.c();
      }
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "Select");
      toggle_class(
        input,
        "invalid",
        /*$errors*/
        ctx[2].length > 0
      );
      attr(div0, "class", "badges svelte-168eg05");
      attr(div1, "class", "multi-select-root svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, input);
      append5(div1, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append5(div1, t1);
      append5(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      if (each1_else) {
        each1_else.m(div0, null);
      }
      if (!mounted) {
        dispose = action_destroyer(createInput_action = /*createInput*/
        ctx[4].call(null, input));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$errors*/
      4) {
        toggle_class(
          input,
          "invalid",
          /*$errors*/
          ctx2[2].length > 0
        );
      }
      if (dirty & /*$errors*/
      4) {
        each_value_1 = ensure_array_like(
          /*$errors*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, t1);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*removeValue, $values*/
      40) {
        each_value = ensure_array_like(
          /*$values*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each1_else) {
          each1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each1_else = create_else_block(ctx2);
          each1_else.c();
          each1_else.m(div0, null);
        } else if (each1_else) {
          each1_else.d(1);
          each1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (each1_else)
        each1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let remainingOptions;
  let $errors, $$unsubscribe_errors = noop, $$subscribe_errors = () => ($$unsubscribe_errors(), $$unsubscribe_errors = subscribe(errors, ($$value) => $$invalidate(2, $errors = $$value)), errors);
  let $values, $$unsubscribe_values = noop, $$subscribe_values = () => ($$unsubscribe_values(), $$unsubscribe_values = subscribe(values, ($$value) => $$invalidate(3, $values = $$value)), values);
  $$self.$$.on_destroy.push(() => $$unsubscribe_errors());
  $$self.$$.on_destroy.push(() => $$unsubscribe_values());
  let { availableOptions = [] } = $$props;
  let { errors } = $$props;
  $$subscribe_errors();
  let { values } = $$props;
  $$subscribe_values();
  let { setting } = $$props;
  let { app: app2 } = $$props;
  setting.settingEl.setCssStyles({ alignItems: "baseline" });
  function createInput(element2) {
    new MultiSuggest(
      element2,
      remainingOptions,
      (selected) => {
        remainingOptions.delete(selected);
        remainingOptions = remainingOptions;
        values.update((x) => [...x, selected]);
      },
      app2
    );
  }
  function removeValue(value) {
    remainingOptions.add(value);
    remainingOptions = remainingOptions;
    values.update((xs) => pipe2(xs, A.filter((x) => x !== value)));
  }
  const click_handler = (value) => removeValue(value);
  $$self.$$set = ($$props2) => {
    if ("availableOptions" in $$props2)
      $$invalidate(6, availableOptions = $$props2.availableOptions);
    if ("errors" in $$props2)
      $$subscribe_errors($$invalidate(0, errors = $$props2.errors));
    if ("values" in $$props2)
      $$subscribe_values($$invalidate(1, values = $$props2.values));
    if ("setting" in $$props2)
      $$invalidate(7, setting = $$props2.setting);
    if ("app" in $$props2)
      $$invalidate(8, app2 = $$props2.app);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*availableOptions*/
    64) {
      $:
        remainingOptions = new Set(availableOptions);
    }
  };
  return [
    errors,
    values,
    $errors,
    $values,
    createInput,
    removeValue,
    availableOptions,
    setting,
    app2,
    click_handler
  ];
}
var MultiSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        availableOptions: 6,
        errors: 0,
        values: 1,
        setting: 7,
        app: 8
      },
      add_css
    );
  }
};
var MultiSelect_default = MultiSelect;

// node_modules/fp-ts/es6/string.js
var Eq = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Semigroup2 = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var empty3 = "";
var Monoid = {
  concat: Semigroup2.concat,
  empty: empty3
};
var Ord = {
  equals: Eq.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};
var trim = function(s) {
  return s.trim();
};
var split = function(separator) {
  return function(s) {
    var out = s.split(separator);
    return isNonEmpty2(out) ? out : [s];
  };
};

// node_modules/fp-ts/es6/ReadonlyRecord.js
function filterMapWithIndex2(f2) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var ob = f2(k, r[k]);
        if (isSome(ob)) {
          out[k] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}
function fromFoldable(M, F) {
  var fromFoldableMapM = fromFoldableMap(M, F);
  return function(fka) {
    return fromFoldableMapM(fka, identity);
  };
}
function fromFoldableMap(M, F) {
  return function(ta, f2) {
    return F.reduce(ta, {}, function(r, a) {
      var _a = f2(a), k = _a[0], b = _a[1];
      r[k] = has.call(r, k) ? M.concat(r[k], b) : b;
      return r;
    });
  };
}

// node_modules/fp-ts/es6/Record.js
var keys_ = function(O2) {
  return function(r) {
    return Object.keys(r).sort(O2.compare);
  };
};
function collect(O2) {
  if (typeof O2 === "function") {
    return collect(Ord)(O2);
  }
  var keysO = keys_(O2);
  return function(f2) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f2(key, r[key]));
      }
      return out;
    };
  };
}
var toArray = /* @__PURE__ */ collect(Ord)(function(k, a) {
  return [
    k,
    a
  ];
});
var filterMapWithIndex3 = filterMapWithIndex2;
function filterWithIndex2(predicateWithIndex) {
  return filterWithIndex(predicateWithIndex);
}
function fromFoldable2(M, F) {
  return fromFoldable(M, F);
}
var toEntries = toArray;
var fromEntries = function(fa) {
  return fromFoldable2(last(), Foldable)(fa);
};

// src/core/objectSelect.ts
var KeysSchema = array(coerce(string(), String));
var PickOmitSchema = object({
  pick: optional(KeysSchema),
  omit: optional(KeysSchema)
});
function picKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => keys.includes(k))
  );
}
function omitKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => !keys.includes(k))
  );
}
function objectSelect(obj, opts) {
  return pipe2(
    parse2(PickOmitSchema, opts, { abortEarly: true }),
    E.map(
      (opts2) => {
        const picked = pipe2(
          fromNullable2(opts2.pick),
          flatMap2(fromArray),
          map3(picKeys(obj)),
          getOrElse2(() => obj)
        );
        return pipe2(
          fromNullable2(opts2.omit),
          flatMap2(fromArray),
          map3(omitKeys(picked)),
          getOrElse2(() => picked)
        );
      }
    ),
    E.getOrElse(() => obj)
  );
}

// src/core/FormResult.ts
var import_obsidian3 = require("obsidian");
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number";
}
function isPrimitiveArray(value) {
  return Array.isArray(value) && value.every(isPrimitive);
}
var FormResult = class {
  constructor(data, status) {
    this.data = data;
    this.status = status;
    /* == Aliases ==*/
    /**
     * just an alias for `asFrontmatterString`
     */
    this.asFrontmatter = this.asFrontmatterString;
    /**
     * just an alias for `asFrontmatterString`
     */
    this.asYaml = this.asFrontmatterString;
    /**
     * just an alias for `asDataviewProperties`
     */
    this.asDataview = this.asDataviewProperties;
    /**
     * just an alias for `asDataviewProperties`
     */
    this.asDv = this.asDataviewProperties;
  }
  /**
   * Transform  the current data into a frontmatter string, which is expected
   * to be enclosed in `---` when used in a markdown file.
   * This method does not add the enclosing `---` to the string,
   * so you can put it anywhere inside the frontmatter.
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns the data formatted as a frontmatter string
   */
  asFrontmatterString(options) {
    const data = objectSelect(this.data, options);
    return (0, import_obsidian3.stringifyYaml)(data);
  }
  /**
   * Return the current data as a block of dataview properties
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns string
   */
  asDataviewProperties(options) {
    const data = objectSelect(this.data, options);
    return Object.entries(data).map(
      ([key, value]) => `${key}:: ${Array.isArray(value) ? value.map((v) => JSON.stringify(v)) : value}`
    ).join("\n");
  }
  /**
  Returns a copy of the data contained on this result.
  */
  getData() {
    return { ...this.data };
  }
  /**
   * Returns the data formatted as a string matching the provided
   * template.
   */
  asString(template) {
    let result = template;
    for (const [key, value] of Object.entries(this.data)) {
      result = result.replace(new RegExp(`{{${key}}}`, "g"), value + "");
    }
    return result;
  }
  /**
   * Gets a single value from the data.
   * It takes an optiional mapping function thatt can be used to transform the value.
   * The function will only be called if the value exists.
   * @param {string} key the key to get the value from
   * @param {function} [mapFn] a function to transform the value
   * @returns the value transformed by the function if it was provided, the value or empty string if it doesn't exist
   */
  get(key, mapFn) {
    const value = this.data[key];
    if (value === void 0) {
      return "";
    }
    if (mapFn) {
      return mapFn(value);
    }
    if (typeof value === "object") {
      return JSON.stringify(value);
    }
    return value;
  }
};

// src/utils/Log.ts
var import_obsidian4 = require("obsidian");
function log_notice(title, msg, titleClass, bodyClass) {
  const notice = new import_obsidian4.Notice("", 15e3);
  const el = notice.noticeEl;
  el.empty();
  const head5 = el.createEl("h6", { text: title, cls: titleClass });
  head5.setCssStyles({ marginTop: "0px" });
  const body = el.createEl("div", { text: msg, cls: bodyClass });
  el.append(head5, body);
}
function log_error(e) {
  if (e instanceof ModalFormError && e.console_msg) {
    log_notice("Modal from error: ", e.message + "\n" + e.console_msg, "var(--text-error)");
    console.error(`Modal form Error:`, e.message, "\n", e.console_msg);
  } else {
    log_notice("Modal from error", e.message);
  }
}

// src/core/formDataFromFormDefaults.ts
function formDataFromFormDefaults(fields, values) {
  const result = {};
  const invalidKeys = [];
  for (const [key, value] of Object.entries(values)) {
    if (Array.isArray(value) && isPrimitiveArray(value)) {
      result[key] = value;
    } else if (isPrimitive(value)) {
      result[key] = value;
    } else {
      invalidKeys.push(key);
    }
  }
  if (invalidKeys.length > 0) {
    log_error(new ModalFormError(`Invalid keys in form options: ${invalidKeys.join(", ")}`));
  }
  return pipe2(
    fields,
    A.map((field) => {
      return pipe2(
        result[field.name],
        fromNullable2,
        match2(() => field.input.type === "toggle" ? some3(false) : none2, some3),
        map3((value) => [field.name, value])
      );
    }),
    A.compact,
    fromEntries
  );
}

// src/safety.ts
function exhaustiveGuard(_value) {
  throw new Error(
    `ERROR! Reached forbidden guard function with unexpected value: ${JSON.stringify(
      _value
    )}`
  );
}

// src/utils/files.ts
var import_obsidian5 = require("obsidian");
var FolderDoesNotExistError = class extends Error {
};
FolderDoesNotExistError.tag = "FolderDoesNotExistError";
var NotAFolderError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a folder`);
    this.file = file;
  }
};
NotAFolderError.tag = "NotAFolderError";
var _FileDoesNotExistError = class extends Error {
  static of(file) {
    return new _FileDoesNotExistError(`File "${file}" doesn't exist`);
  }
};
var FileDoesNotExistError = _FileDoesNotExistError;
FileDoesNotExistError.tag = "FileDoesNotExistError";
var NotAFileError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a file`);
    this.file = file;
  }
};
NotAFileError.tag = "NotAFileError";
function resolve_tfolder(folder_str, app2) {
  return pipe2(
    (0, import_obsidian5.normalizePath)(folder_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    E.fromNullable(new FolderDoesNotExistError(`Folder "${folder_str}" doesn't exist`)),
    E.flatMap((file) => {
      if (!(file instanceof import_obsidian5.TFolder)) {
        return E.left(new NotAFolderError(file));
      }
      return E.right(file);
    })
  );
}
function get_tfiles_from_folder(folder_str, app2) {
  return pipe2(
    resolve_tfolder(folder_str, app2),
    E.flatMap((folder) => {
      const files = [];
      import_obsidian5.Vault.recurseChildren(folder, (file) => {
        if (file instanceof import_obsidian5.TFile) {
          files.push(file);
        }
      });
      return E.right(files);
    }),
    E.map(
      (files) => {
        return files.sort((a, b) => {
          return a.basename.localeCompare(b.basename);
        });
      }
    )
  );
}
function file_exists(file_str, app2) {
  return pipe2(
    (0, import_obsidian5.normalizePath)(file_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    (value) => value !== null
  );
}

// src/suggesters/suggestFile.ts
var import_obsidian6 = require("obsidian");
var FileSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app2, inputEl, strategy, folder) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.strategy = strategy;
    this.folder = folder;
  }
  getSuggestions(input_str) {
    const all_files = get_tfiles_from_folder(this.folder, this.app);
    if (E.isLeft(all_files)) {
      return [];
    }
    const lower_input_str = input_str.toLowerCase();
    return all_files.right.filter((file) => {
      return file instanceof import_obsidian6.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str);
    });
  }
  renderSuggestion(file, el) {
    el.setText(this.strategy.renderSuggestion(file));
  }
  selectSuggestion(file) {
    this.inputEl.value = this.strategy.selectSuggestion(file);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/suggestFromDataview.ts
var import_obsidian7 = require("obsidian");

// src/suggesters/SafeDataviewQuery.ts
function sandboxedDvQuery(query) {
  if (!query.startsWith("return")) {
    query = "return " + query;
  }
  const run3 = new Function("dv", "pages", query);
  return flow2(
    E.tryCatchK(run3, () => new ModalFormError("Error evaluating the dataview query")),
    E.flatMap((result) => {
      if (!Array.isArray(result)) {
        return E.left(new ModalFormError("The dataview query did not return an array"));
      }
      return E.right(result);
    })
  );
}
function executeSandboxedDvQuery(query, app2) {
  var _a;
  const dv = (_a = app2.plugins.plugins.dataview) == null ? void 0 : _a.api;
  if (!dv) {
    log_error(new ModalFormError("Dataview plugin is not enabled"));
    return [];
  }
  const pages = dv.pages;
  return pipe2(
    query(dv, pages),
    E.getOrElse((e) => {
      log_error(e);
      return [];
    })
  );
}

// src/suggesters/createRegexFromInput.ts
var splitString = flow2(trim, split(" "));
function createRegexFromInput(input) {
  return pipe2(
    fromNullable2(input),
    map3(splitString),
    map3((parts) => parts.join(".*")),
    map3((s) => new RegExp(s, "i")),
    getOrElse2(() => new RegExp(".*"))
  );
}

// src/suggesters/suggestFromDataview.ts
var DataviewSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(inputEl, dvQuery, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
    this.sandboxedQuery = sandboxedDvQuery(dvQuery);
  }
  getSuggestions(inputStr) {
    const result = executeSandboxedDvQuery(this.sandboxedQuery, this.app);
    if (!inputStr) {
      return result;
    }
    const regex = createRegexFromInput(inputStr);
    return result.filter((r) => regex.test(r));
  }
  renderSuggestion(option, el) {
    el.setText(option);
  }
  selectSuggestion(option) {
    this.inputEl.value = option;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/store/formStore.ts
var import_function8 = __toESM(require_function());

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update3(fn) {
    set2(fn(value));
  }
  function subscribe3(run3, invalidate = noop) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update3) || noop;
    }
    run3(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update3, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update3) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update3);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/store/formStore.ts
function requiredRule(fieldName, message) {
  return { tag: "required", message: message != null ? message : `'${fieldName}' is required` };
}
function FieldFailed(field, failedRule) {
  return { ...field, rules: failedRule, errors: [failedRule.message] };
}
function nonEmptyValue(s) {
  switch (typeof s) {
    case "string":
      return s.length > 0 ? some3(s) : none2;
    case "number":
    case "boolean":
      return some3(s);
    case "object":
      return Array.isArray(s) ? s.length > 0 ? some3(s) : none2 : none2;
    default:
      return (0, import_function8.absurd)(s);
  }
}
function parseField(field) {
  if (!field.rules)
    return right2(field);
  const rule = field.rules;
  switch (rule.tag) {
    case "required":
      return pipe2(
        field.value,
        chain2(nonEmptyValue),
        match2(
          () => left2(FieldFailed(field, rule)),
          (value) => right2(field)
        )
      );
    default:
      return (0, import_function8.absurd)(rule.tag);
  }
}
function parseForm(fields) {
  const { right: ok, left: failed } = pipe2(
    fields,
    Object.values,
    map2(parseField),
    separate
  );
  if (failed.length > 0)
    return left2(failed);
  return right2(
    pipe2(
      ok,
      map2(
        (field) => pipe2(
          field.value,
          map3((value) => [field.name, value])
        )
      ),
      compact,
      fromEntries
    )
  );
}
function makeFormEngine(onSubmit, defaultValues = {}) {
  const formStore = writable({ fields: {} });
  function setFormField(name) {
    function initField(errors = [], rules) {
      formStore.update((form) => {
        return {
          ...form,
          fields: {
            ...form.fields,
            [name]: { value: fromNullable2(defaultValues[name]), name, errors, rules }
          }
        };
      });
    }
    function setValue(value) {
      formStore.update((form) => {
        const field = form.fields[name];
        if (!field) {
          console.error(new Error(`Field ${name} does not exist`));
          return form;
        }
        return {
          ...form,
          fields: {
            ...form.fields,
            [name]: { ...field, value: some3(value), errors: [] }
          }
        };
      });
    }
    return { initField, setValue };
  }
  function setErrors(failedFields) {
    formStore.update((form) => {
      return pipe2(
        failedFields,
        reduce2(form, (form2, field) => {
          return {
            ...form2,
            fields: { ...form2.fields, [field.name]: field }
          };
        })
      );
    });
  }
  return {
    subscribe: formStore.subscribe,
    isValid: derived(
      formStore,
      ({ fields }) => pipe2(
        fields,
        toEntries,
        some2(([_, f2]) => f2.errors.length > 0),
        (x) => !x
      )
    ),
    triggerSubmit() {
      const formState = get_store_value(formStore);
      pipe2(
        formState.fields,
        parseForm,
        match(setErrors, onSubmit)
      );
    },
    addField: (field) => {
      const { initField: setField, setValue } = setFormField(field.name);
      setField(
        [],
        field.isRequired ? requiredRule(field.label || field.name) : void 0
      );
      const fieldStore = derived(
        formStore,
        ({ fields }) => fields[field.name]
      );
      const fieldValueStore = {
        subscribe(cb) {
          return fieldStore.subscribe(
            (x) => pipe2(
              x,
              fromNullable2,
              chain2((x2) => x2.value),
              map3(cb)
            )
          );
        },
        set(value) {
          setValue(value);
        },
        update: (updater) => {
          formStore.update((form) => {
            const current = form.fields[field.name];
            if (!current) {
              console.error(
                new Error(`Field ${field.name} does not exist`)
              );
              return form;
            }
            const newValue = pipe2(
              current.value,
              map3(updater)
            );
            return {
              ...form,
              fields: {
                ...form.fields,
                [field.name]: {
                  ...current,
                  value: newValue,
                  errors: []
                }
              }
            };
          });
        }
      };
      return {
        value: fieldValueStore,
        errors: derived(
          formStore,
          ({ fields }) => {
            var _a, _b;
            return (_b = (_a = fields[field.name]) == null ? void 0 : _a.errors) != null ? _b : [];
          }
        )
      };
    }
  };
}

// src/suggesters/suggestFolder.ts
var import_obsidian8 = require("obsidian");
var FolderSuggest = class extends import_obsidian8.AbstractInputSuggest {
  constructor(inputEl, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = abstractFiles.reduce((acc, folder) => {
      if (folder instanceof import_obsidian8.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        acc.push(folder);
      }
      return acc;
    }, []);
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/FormModal.ts
var FormModal = class extends import_obsidian9.Modal {
  constructor(app2, modalDefinition, onSubmit, options) {
    var _a;
    super(app2);
    this.modalDefinition = modalDefinition;
    this.onSubmit = onSubmit;
    this.svelteComponents = [];
    this.subscriptions = [];
    this.initialFormValues = formDataFromFormDefaults(modalDefinition.fields, (_a = options == null ? void 0 : options.values) != null ? _a : {});
    this.formEngine = makeFormEngine((result) => {
      this.onSubmit(new FormResult(result, "ok"));
      this.close();
    }, this.initialFormValues);
    this.formEngine.subscribe(console.log);
  }
  // onOpen2() {
  //     const { contentEl } = this;
  //     const component = new FormModalComponent({
  //         target: contentEl,
  //         props: {
  //             onSubmit: this.onSubmit,
  //             formDefinition: this.modalDefinition,
  //         },
  //     });
  //     this.svelteComponents.push(component);
  // }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("modal-form");
    if (this.modalDefinition.customClassname)
      contentEl.addClass(this.modalDefinition.customClassname);
    contentEl.createEl("h1", { text: this.modalDefinition.title });
    this.modalDefinition.fields.forEach((definition) => {
      const fieldBase = new import_obsidian9.Setting(contentEl).setName(definition.label || definition.name).setDesc(definition.description);
      const fieldInput = definition.input;
      const type = fieldInput.type;
      const initialValue = this.initialFormValues[definition.name];
      const fieldStore = this.formEngine.addField(definition);
      const subToErrors = (input) => {
        const notify = throttle((msg) => log_notice("\u26A0\uFE0F The form has errors \u26A0\uFE0F", msg, "notice-warning"), 2e3);
        this.subscriptions.push(
          fieldStore.errors.subscribe((errs) => {
            console.log("errors", errs);
            errs.forEach(notify);
            input.setCustomValidity(errs.join("\n"));
          })
        );
      };
      switch (type) {
        case "textarea": {
          fieldBase.setClass("modal-form-textarea");
          return fieldBase.addTextArea((textEl) => {
            textEl.onChange(fieldStore.value.set);
            subToErrors(textEl.inputEl);
            if (typeof initialValue === "string") {
              textEl.setValue(initialValue);
            }
            textEl.inputEl.rows = 6;
            if (import_obsidian9.Platform.isIosApp)
              textEl.inputEl.style.width = "100%";
            else if (import_obsidian9.Platform.isDesktopApp) {
              textEl.inputEl.rows = 10;
            }
          });
        }
        case "email":
        case "tel":
        case "date":
        case "time":
        case "text":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = type;
            subToErrors(text3.inputEl);
            text3.onChange(fieldStore.value.set);
            initialValue !== void 0 && text3.setValue(String(initialValue));
          });
        case "number":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = "number";
            subToErrors(text3.inputEl);
            text3.onChange((val) => {
              if (val !== "") {
                fieldStore.value.set(Number(val) + "");
              }
            });
            initialValue !== void 0 && text3.setValue(String(initialValue));
          });
        case "datetime":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = "datetime-local";
            initialValue !== void 0 && text3.setValue(String(initialValue));
            subToErrors(text3.inputEl);
            text3.onChange(fieldStore.value.set);
          });
        case "toggle":
          return fieldBase.addToggle((toggle) => {
            toggle.setValue(!!initialValue);
            return toggle.onChange(fieldStore.value.set);
          });
        case "note":
          return fieldBase.addText((element2) => {
            new FileSuggest(
              this.app,
              element2.inputEl,
              {
                renderSuggestion(file) {
                  return file.basename;
                },
                selectSuggestion(file) {
                  return file.basename;
                }
              },
              fieldInput.folder
            );
            subToErrors(element2.inputEl);
            element2.onChange(fieldStore.value.set);
          });
        case "folder":
          return fieldBase.addText((element2) => {
            new FolderSuggest(
              element2.inputEl,
              this.app
            );
            subToErrors(element2.inputEl);
            element2.onChange(fieldStore.value.set);
          });
        case "slider":
          return fieldBase.addSlider((slider) => {
            slider.setLimits(fieldInput.min, fieldInput.max, 1);
            slider.setDynamicTooltip();
            if (typeof initialValue === "number") {
              slider.setValue(initialValue);
            } else {
              slider.setValue(fieldInput.min);
            }
            slider.onChange(fieldStore.value.set);
          });
        case "multiselect": {
          const source = fieldInput.source;
          const options = source == "fixed" ? fieldInput.multi_select_options : source == "notes" ? pipe2(
            get_tfiles_from_folder(
              fieldInput.folder,
              this.app
            ),
            E.map(A.map((file) => file.basename)),
            E.getOrElse((err) => {
              log_error(err);
              return [];
            })
          ) : executeSandboxedDvQuery(
            sandboxedDvQuery(fieldInput.query),
            this.app
          );
          fieldStore.value.set(initialValue != null ? initialValue : []);
          this.svelteComponents.push(
            new MultiSelect_default({
              target: fieldBase.controlEl,
              props: {
                values: fieldStore.value,
                availableOptions: options,
                errors: fieldStore.errors,
                setting: fieldBase,
                app: this.app
              }
            })
          );
          return;
        }
        case "tag": {
          const options = Object.keys(
            this.app.metadataCache.getTags()
          ).map((tag) => tag.slice(1));
          fieldStore.value.set(initialValue != null ? initialValue : []);
          this.svelteComponents.push(
            new MultiSelect_default({
              target: fieldBase.controlEl,
              props: {
                values: fieldStore.value,
                availableOptions: options,
                setting: fieldBase,
                errors: fieldStore.errors,
                app: this.app
              }
            })
          );
          return;
        }
        case "dataview": {
          const query = fieldInput.query;
          return fieldBase.addText((element2) => {
            new DataviewSuggest(element2.inputEl, query, this.app);
            element2.onChange(fieldStore.value.set);
            subToErrors(element2.inputEl);
          });
        }
        case "select":
          {
            const source = fieldInput.source;
            switch (source) {
              case "fixed":
                return fieldBase.addDropdown((element2) => {
                  fieldInput.options.forEach((option) => {
                    element2.addOption(
                      option.value,
                      option.label
                    );
                  });
                  fieldStore.value.set(element2.getValue());
                  element2.onChange(fieldStore.value.set);
                });
              case "notes":
                return fieldBase.addDropdown((element2) => {
                  const files = get_tfiles_from_folder(
                    fieldInput.folder,
                    this.app
                  );
                  pipe2(
                    files,
                    E.map(
                      (files2) => files2.reduce(
                        (acc, option) => {
                          acc[option.basename] = option.basename;
                          return acc;
                        },
                        {}
                      )
                    ),
                    E.mapLeft((err) => {
                      log_error(err);
                      return err;
                    }),
                    E.map((options) => {
                      element2.addOptions(options);
                    })
                  );
                  fieldStore.value.set(element2.getValue());
                  element2.onChange(fieldStore.value.set);
                });
              default:
                exhaustiveGuard(source);
            }
          }
          break;
        default:
          return exhaustiveGuard(type);
      }
    });
    new import_obsidian9.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(this.formEngine.triggerSubmit)
    );
    const submitEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        this.formEngine.triggerSubmit();
      }
    };
    contentEl.addEventListener("keydown", submitEnterCallback);
  }
  onClose() {
    const { contentEl } = this;
    this.svelteComponents.forEach((component) => component.$destroy());
    this.subscriptions.forEach((subscription) => subscription());
    contentEl.empty();
    this.initialFormValues = {};
  }
};

// src/API.ts
function isPickOption(opts) {
  return "pick" in opts && Array.isArray(opts.pick);
}
function isOmitOption(opts) {
  return "omit" in opts && Array.isArray(opts.omit);
}
var API = class {
  /**
   * Constructor for the API class
   * @param {App} app - The application instance
   * @param {typeof ModalFormPlugin} plugin - The plugin instance
   */
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  /**
   * Opens a modal form with the provided form definition
   * @param {FormDefinition} formDefinition - The form definition to use
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   */
  openModalForm(formDefinition, options) {
    return new Promise((resolve) => {
      new FormModal(this.app, formDefinition, resolve, options).open();
    });
  }
  exampleForm(options) {
    return this.openModalForm(exampleModalDefinition, options);
  }
  getFormByName(name) {
    var _a;
    const form = (_a = this.plugin.settings) == null ? void 0 : _a.formDefinitions.find(
      (form2) => form2.name === name
    );
    if (form instanceof MigrationError) {
      log_notice(
        "\u{1F6AB} The form you tried to load has an invalid format",
        `The form "${name}" has an invalid format.We tried to automatically convert it but it failed, please fix it manually in the forms manager.
            `
      );
      return void 0;
    } else {
      return form;
    }
  }
  /**
   * Opens a named form
   * @param {string} name - The name of the form to open
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form definition is not found
   */
  namedForm(name, options) {
    const formDefinition = this.getFormByName(name);
    if (formDefinition) {
      return this.openModalForm(formDefinition, options);
    } else {
      const error2 = new ModalFormError(
        `Form definition ${name} not found`
      );
      log_error(error2);
      return Promise.reject(error2);
    }
  }
  limitedForm(name, opts) {
    const formDefinition = this.getFormByName(name);
    let newFormDefinition;
    if (formDefinition) {
      if (isOmitOption(opts)) {
        const omit = opts.omit;
        newFormDefinition = {
          ...formDefinition,
          fields: formDefinition.fields.filter(
            (field) => !omit.includes(field.name)
          )
        };
      } else if (isPickOption(opts)) {
        newFormDefinition = {
          ...formDefinition,
          fields: formDefinition.fields.filter(
            (field) => opts.pick.includes(field.name)
          )
        };
      } else {
        throw new ModalFormError(
          "Invalid options provided to limitedForm",
          `GOT: ${JSON.stringify(opts)}`
        );
      }
      return this.openModalForm(newFormDefinition);
    } else {
      const error2 = new ModalFormError(
        `Form definition ${name} not found`
      );
      log_error(error2);
      return Promise.reject(error2);
    }
  }
  /**
   * Opens a form with the provided form reference
   * @param {string | FormDefinition} formReference - The form reference, either a form name of an existing form or an inline form definition
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form reference is not found
   */
  openForm(formReference, options) {
    if (typeof formReference === "string") {
      return this.namedForm(formReference, options);
    } else {
      return this.openModalForm(formReference, options);
    }
  }
};

// src/views/EditFormView.ts
var import_obsidian14 = require("obsidian");

// src/core/formDefinition.ts
var FieldTypeReadable = {
  text: "Text",
  number: "Number",
  tag: "Tags",
  email: "Email",
  tel: "Phone",
  date: "Date",
  time: "Time",
  datetime: "DateTime",
  textarea: "Text area",
  toggle: "Toggle",
  note: "Note",
  folder: "Folder",
  slider: "Slider",
  select: "Select",
  dataview: "Dataview",
  multiselect: "Multiselect"
};
function validateFields(fields) {
  const result = safeParse(FieldListSchema, fields);
  if (result.success) {
    return [];
  }
  console.error("Fields issues", result.issues);
  return result.issues.map((issue) => {
    var _a, _b, _c, _d;
    return {
      message: issue.message,
      path: (_a = issue.path) == null ? void 0 : _a.map((item2) => item2.key).join("."),
      index: (_d = (_c = (_b = issue.path) == null ? void 0 : _b[0]) == null ? void 0 : _c.key) != null ? _d : 0
    };
  });
}
function isValidFormDefinition(input) {
  if (!is(FormDefinitionBasicSchema, input)) {
    return false;
  }
  console.log("basic is valid");
  const fieldsAreValid = is(FieldListSchema, input.fields);
  if (!fieldsAreValid) {
    return false;
  }
  console.log("fields are valid");
  return true;
}
function duplicateForm(formName, forms) {
  return pipe2(
    forms,
    A.findFirstMap((f2) => {
      if (f2 instanceof MigrationError) {
        return O.none;
      }
      if (f2.name === formName) {
        return O.some(f2);
      }
      return O.none;
    }),
    O.map((f2) => {
      let newName = f2.name + "-copy";
      let i = 1;
      while (forms.some((f3) => f3.name === newName)) {
        newName = f2.name + "-copy-" + i;
        i++;
      }
      return { ...f2, name: newName };
    }),
    O.map((f2) => {
      return [...forms, f2];
    }),
    O.getOrElse(() => forms)
  );
}

// src/views/FormBuilder.svelte
var import_obsidian13 = require("obsidian");

// src/views/components/FormRow.svelte
function add_css2(target) {
  append_styles(target, "svelte-1xgum2", ".field-goup.svelte-1xgum2{display:flex;flex-direction:column;gap:0.5rem}.hidden-label.svelte-1xgum2{white-space:nowrap;overflow:hidden;visibility:hidden}");
}
function create_fragment2(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(
        label_1,
        "for",
        /*id*/
        ctx[1]
      );
      attr(label_1, "class", "svelte-1xgum2");
      toggle_class(
        label_1,
        "hidden-label",
        /*hideLabel*/
        ctx[2]
      );
      attr(div, "class", "field-goup svelte-1xgum2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, label_1);
      append5(label_1, t0);
      append5(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*label*/
      1)
        set_data(
          t0,
          /*label*/
          ctx2[0]
        );
      if (!current || dirty & /*id*/
      2) {
        attr(
          label_1,
          "for",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*hideLabel*/
      4) {
        toggle_class(
          label_1,
          "hidden-label",
          /*hideLabel*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label } = $$props;
  let { id } = $$props;
  let { hideLabel = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("hideLabel" in $$props2)
      $$invalidate(2, hideLabel = $$props2.hideLabel);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [label, id, hideLabel, $$scope, slots];
}
var FormRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance2, create_fragment2, safe_not_equal, { label: 0, id: 1, hideLabel: 2 }, add_css2);
  }
};
var FormRow_default = FormRow;

// src/views/components/inputBuilderDataview.svelte
function create_default_slot(ctx) {
  let span;
  let t8;
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      span.innerHTML = `This is a <a href="https://blacksmithgu.github.io/obsidian-dataview/api/intro/">Dataview</a>
        query that will be used to populate the input suggestions. You should provide
        a query that returns a list of strings, for example:
        <pre class="language-js"><code>dv.pages(&#39;#tag&#39;).map(p =&gt; p.file.name)</code></pre>
        It is recommended to take advantage of<a href="https://blacksmithgu.github.io/obsidian-dataview/api/data-array">Swizzling</a>
        to write shorter queries:
        <pre class="language-js"><code>dv.pages.tag(&#39;#tag&#39;).file.name</code></pre>`;
      t8 = space();
      textarea = element("textarea");
      attr(span, "class", "modal-form-hint");
      attr(
        textarea,
        "id",
        /*id*/
        ctx[1]
      );
      attr(textarea, "name", "dataview_query");
      attr(textarea, "class", "form-control");
      attr(textarea, "rows", "3");
      attr(textarea, "placeholder", "dv.pages('#tag').map(p => p.file.name)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t8, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*id*/
      2) {
        attr(
          textarea,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t8);
        detach(textarea);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Dataview Query",
      id: (
        /*id*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      2)
        formrow_changes.id = /*id*/
        ctx2[1];
      if (dirty & /*$$scope, id, value*/
      19) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let id;
  let { index } = $$props;
  let { value = "" } = $$props;
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(2, index = $$props2.index);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    4) {
      $:
        $$invalidate(1, id = `dataview_${index}`);
    }
  };
  return [value, id, index, textarea_input_handler];
}
var InputBuilderDataview = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance3, create_fragment3, safe_not_equal, { index: 2, value: 0 });
  }
};
var inputBuilderDataview_default = InputBuilderDataview;

// src/views/components/InputBuilderSelect.svelte
var import_obsidian11 = require("obsidian");

// src/views/components/InputFolder.svelte
var import_obsidian10 = require("obsidian");
function create_fragment4(ctx) {
  let div;
  let label;
  let t;
  let searchFolder_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t = text("Source Folder");
      attr(
        label,
        "for",
        /*id*/
        ctx[0]
      );
      attr(div, "class", "modal-form flex column gap1 remove-padding remove-border fix-suggest");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, label);
      append5(label, t);
      if (!mounted) {
        dispose = action_destroyer(searchFolder_action = /*searchFolder*/
        ctx[1].call(null, div));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      1) {
        attr(
          label,
          "for",
          /*id*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let id;
  let { index } = $$props;
  let { folder = "" } = $$props;
  let { notifyChange } = $$props;
  function searchFolder(element2) {
    new import_obsidian10.Setting(element2).addSearch((search) => {
      search.setPlaceholder("Select a folder");
      search.setValue(folder);
      new FolderSuggest(search.inputEl, app);
      search.onChange((value) => {
        $$invalidate(2, folder = value);
        notifyChange();
      });
    });
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(3, index = $$props2.index);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("notifyChange" in $$props2)
      $$invalidate(4, notifyChange = $$props2.notifyChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    8) {
      $:
        $$invalidate(0, id = `input_folder_${index}`);
    }
  };
  return [id, searchFolder, folder, index, notifyChange];
}
var InputFolder = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance4, create_fragment4, safe_not_equal, { index: 3, folder: 2, notifyChange: 4 });
  }
};
var InputFolder_default = InputFolder;

// src/views/components/InputBuilderSelect.svelte
function add_css3(target) {
  append_styles(target, "svelte-1on8key", "button.svelte-1on8key:disabled{opacity:0.5;cursor:forbidden}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = list;
  child_ctx[23] = i;
  const constants_0 = `${/*options_id*/
  child_ctx[7]}_option_${/*idx*/
  child_ctx[23]}`;
  child_ctx[21] = constants_0;
  return child_ctx;
}
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `${/*options_id*/
  child_ctx[7]}_option_label_${/*idx*/
  child_ctx[23]}`;
  child_ctx[24] = constants_0;
  return child_ctx;
}
function create_if_block_4(ctx) {
  let option_1;
  return {
    c() {
      option_1 = element("option");
      option_1.textContent = "Dataview";
      option_1.__value = "dataview";
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_default_slot_7(ctx) {
  let select;
  let option0;
  let option1;
  let mounted;
  let dispose;
  let if_block = (
    /*is_multi*/
    ctx[6] && create_if_block_4(ctx)
  );
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "Static";
      option1 = element("option");
      option1.textContent = "Notes";
      if (if_block)
        if_block.c();
      option0.__value = "fixed";
      set_input_value(option0, option0.__value);
      option1.__value = "notes";
      set_input_value(option1, option1.__value);
      attr(
        select,
        "id",
        /*id*/
        ctx[8]
      );
      if (
        /*source*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[10].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append5(select, option0);
      append5(select, option1);
      if (if_block)
        if_block.m(select, null);
      select_option(
        select,
        /*source*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[10]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*is_multi*/
        ctx2[6]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(select, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*id*/
      256) {
        attr(
          select,
          "id",
          /*id*/
          ctx2[8]
        );
      }
      if (dirty & /*source*/
      1) {
        select_option(
          select,
          /*source*/
          ctx2[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[19](value);
  }
  let inputbuilderdataview_props = { index: (
    /*index*/
    ctx[4]
  ) };
  if (
    /*query*/
    ctx[1] !== void 0
  ) {
    inputbuilderdataview_props.value = /*query*/
    ctx[1];
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputbuilderdataview_changes = {};
      if (dirty & /*index*/
      16)
        inputbuilderdataview_changes.index = /*index*/
        ctx2[4];
      if (!updating_value && dirty & /*query*/
      2) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*query*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[18](value);
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[4]
    ),
    notifyChange: (
      /*notifyChange*/
      ctx[5]
    )
  };
  if (
    /*folder*/
    ctx[2] !== void 0
  ) {
    inputfolder_props.folder = /*folder*/
    ctx[2];
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputfolder_changes = {};
      if (dirty & /*index*/
      16)
        inputfolder_changes.index = /*index*/
        ctx2[4];
      if (dirty & /*notifyChange*/
      32)
        inputfolder_changes.notifyChange = /*notifyChange*/
        ctx2[5];
      if (!updating_folder && dirty & /*folder*/
      4) {
        updating_folder = true;
        inputfolder_changes.folder = /*folder*/
        ctx2[2];
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Options",
      id: (
        /*options_id*/
        ctx[7]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow_changes.id = /*options_id*/
        ctx2[7];
      if (dirty & /*$$scope, options, options_id, notifyChange, is_multi*/
      33554664) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[12](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[23] === 0;
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "arrow-up")),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_5(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[13](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      var _a;
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[23] === /*options*/
      ((_a = ctx[3]) == null ? void 0 : _a.length) - 1;
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "arrow-down")),
          listen(button, "click", click_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty & /*options*/
      8 && button_disabled_value !== (button_disabled_value = /*idx*/
      ctx[23] === /*options*/
      ((_a = ctx[3]) == null ? void 0 : _a.length) - 1)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block2(ctx) {
  let formrow0;
  let formrow1;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Label",
      id: (
        /*label_id*/
        ctx[24]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow0.$$.fragment);
      create_component(formrow1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow0, target, anchor);
      mount_component(formrow1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow0_changes.id = /*label_id*/
        ctx2[24];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow1_changes.id = /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow0, detaching);
      destroy_component(formrow1, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[21]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow_changes.id = /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options*/
      33554568) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[15].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Label");
      attr(input, "id", input_id_value = /*label_id*/
      ctx[24]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20].label
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*label_id*/
      ctx[24])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20].label) {
        set_input_value(
          input,
          /*option*/
          ctx[20].label
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_2() {
    ctx[16].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[21]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20].value
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*value_id*/
      ctx[21])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20].value) {
        set_input_value(
          input,
          /*option*/
          ctx[20].value
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[14].call(
      input,
      /*each_value*/
      ctx[22],
      /*idx*/
      ctx[23]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[21]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[20]
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && input_id_value !== (input_id_value = /*value_id*/
      ctx[21])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      8 && input.value !== /*option*/
      ctx[20]) {
        set_input_value(
          input,
          /*option*/
          ctx[20]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1(ctx) {
  let button;
  let button_id_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[17](
        /*idx*/
        ctx[23]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "id", button_id_value = "button" + /*value_id*/
      ctx[21]);
      attr(button, "type", "button");
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian11.setIcon.call(null, button, "trash")),
          listen(button, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      128 && button_id_value !== (button_id_value = "button" + /*value_id*/
      ctx[21])) {
        attr(button, "id", button_id_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block2(ctx) {
  let div;
  let formrow0;
  let t0;
  let formrow1;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let formrow2;
  let t3;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-up" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-down" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_1, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if ("string" == typeof /*option*/
    ctx2[20])
      return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1)
      return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  formrow2 = new FormRow_default({
    props: {
      label: "Delete",
      id: "button" + /*value_id*/
      ctx[21],
      hideLabel: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(formrow0.$$.fragment);
      t0 = space();
      create_component(formrow1.$$.fragment);
      t1 = space();
      if_block.c();
      t2 = space();
      create_component(formrow2.$$.fragment);
      t3 = space();
      attr(div, "class", "modal-form flex row gap1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(formrow0, div, null);
      append5(div, t0);
      mount_component(formrow1, div, null);
      append5(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      append5(div, t2);
      mount_component(formrow2, div, null);
      append5(div, t3);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow0_changes.id = "button-up" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope*/
      33554432) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow1_changes.id = "button-down" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options*/
      33554440) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
      const formrow2_changes = {};
      if (dirty & /*options_id*/
      128)
        formrow2_changes.id = "button" + /*value_id*/
        ctx2[21];
      if (dirty & /*$$scope, options_id, options, notifyChange*/
      33554600) {
        formrow2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow2.$set(formrow2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      transition_in(if_block);
      transition_in(formrow2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      transition_out(if_block);
      transition_out(formrow2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(formrow0);
      destroy_component(formrow1);
      if_blocks[current_block_type_index].d();
      destroy_component(formrow2);
    }
  };
}
function create_default_slot2(ctx) {
  let button;
  let t1;
  let each_1_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*options*/
    ctx[3] || []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      button = element("button");
      button.textContent = "Add more options";
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty2();
      attr(button, "type", "button");
      attr(button, "class", "svelte-1on8key");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*options_id, options, notifyChange, moveOption*/
      680) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[3] || []
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment5(ctx) {
  let formrow;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Source",
      id: (
        /*id*/
        ctx[8]
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*source*/
      ctx2[0] === "fixed"
    )
      return 0;
    if (
      /*source*/
      ctx2[0] === "notes"
    )
      return 1;
    if (
      /*source*/
      ctx2[0] === "dataview"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      create_component(formrow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      insert(target, t, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      256)
        formrow_changes.id = /*id*/
        ctx2[8];
      if (dirty & /*$$scope, id, source, is_multi*/
      33554753) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(formrow, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let id;
  let options_id;
  let { index } = $$props;
  let { source = "fixed" } = $$props;
  let { query = "" } = $$props;
  let { folder } = $$props;
  let { options = [] } = $$props;
  let { notifyChange } = $$props;
  let { is_multi } = $$props;
  function moveOption(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= options.length)
      return;
    const tmp = options[from];
    const target = options[to];
    if (!target || !tmp)
      return;
    $$invalidate(3, options[from] = target, options);
    $$invalidate(3, options[to] = tmp, options);
    $$invalidate(3, options);
    notifyChange();
  }
  function select_change_handler() {
    source = select_value(this);
    $$invalidate(0, source);
  }
  const click_handler = () => {
    if (is_multi) {
      options == null ? void 0 : options.push("");
    } else {
      options == null ? void 0 : options.push({ value: "", label: "" });
    }
    $$invalidate(3, options);
    notifyChange();
  };
  const click_handler_1 = (idx) => moveOption(idx, "up");
  const click_handler_2 = (idx) => moveOption(idx, "down");
  function input_input_handler(each_value, idx) {
    each_value[idx] = this.value;
    $$invalidate(3, options);
  }
  function input_input_handler_1(each_value, idx) {
    each_value[idx].label = this.value;
    $$invalidate(3, options);
  }
  function input_input_handler_2(each_value, idx) {
    each_value[idx].value = this.value;
    $$invalidate(3, options);
  }
  const click_handler_3 = (idx) => {
    $$invalidate(3, options = options == null ? void 0 : options.filter((_, i) => i !== idx));
    notifyChange();
  };
  function inputfolder_folder_binding(value) {
    folder = value;
    $$invalidate(2, folder);
  }
  function inputbuilderdataview_value_binding(value) {
    query = value;
    $$invalidate(1, query);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(4, index = $$props2.index);
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("query" in $$props2)
      $$invalidate(1, query = $$props2.query);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("options" in $$props2)
      $$invalidate(3, options = $$props2.options);
    if ("notifyChange" in $$props2)
      $$invalidate(5, notifyChange = $$props2.notifyChange);
    if ("is_multi" in $$props2)
      $$invalidate(6, is_multi = $$props2.is_multi);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    16) {
      $:
        $$invalidate(8, id = `builder_select_${index}`);
    }
    if ($$self.$$.dirty & /*index*/
    16) {
      $:
        $$invalidate(7, options_id = `builder_select_options_btn_${index}`);
    }
  };
  return [
    source,
    query,
    folder,
    options,
    index,
    notifyChange,
    is_multi,
    options_id,
    id,
    moveOption,
    select_change_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    input_input_handler,
    input_input_handler_1,
    input_input_handler_2,
    click_handler_3,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding
  ];
}
var InputBuilderSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        index: 4,
        source: 0,
        query: 1,
        folder: 2,
        options: 3,
        notifyChange: 5,
        is_multi: 6
      },
      add_css3
    );
  }
};
var InputBuilderSelect_default = InputBuilderSelect;

// src/views/components/Toggle.svelte
function create_fragment6(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      attr(
        input,
        "tabindex",
        /*tabindex*/
        ctx[1]
      );
      attr(div, "class", "checkbox-container");
      toggle_class(
        div,
        "is-enabled",
        /*checked*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, input);
      input.checked = /*checked*/
      ctx[0];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[2]
          ),
          listen(
            div,
            "click",
            /*click_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabindex*/
      2) {
        attr(
          input,
          "tabindex",
          /*tabindex*/
          ctx2[1]
        );
      }
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (dirty & /*checked*/
      1) {
        toggle_class(
          div,
          "is-enabled",
          /*checked*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { checked = false } = $$props;
  let { tabindex = 0 } = $$props;
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  const click_handler = () => $$invalidate(0, checked = !checked);
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("tabindex" in $$props2)
      $$invalidate(1, tabindex = $$props2.tabindex);
  };
  return [checked, tabindex, input_change_handler, click_handler];
}
var Toggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance6, create_fragment6, safe_not_equal, { checked: 0, tabindex: 1 });
  }
};
var Toggle_default = Toggle;

// node_modules/parser-ts/es6/ParseResult.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var success = function(value, next, start) {
  return right2({
    value,
    next,
    start
  });
};
var error = function(input, expected2, fatal) {
  if (expected2 === void 0) {
    expected2 = [];
  }
  if (fatal === void 0) {
    fatal = false;
  }
  return left2({
    input,
    expected: expected2,
    fatal
  });
};
var withExpected = function(err, expected2) {
  return __assign(__assign({}, err), { expected: expected2 });
};
var extend = function(err1, err2) {
  return getSemigroup3().concat(err1, err2);
};
var getSemigroup3 = function() {
  return {
    concat: function(x, y) {
      if (x.input.cursor < y.input.cursor)
        return last().concat(x, y);
      if (x.input.cursor > y.input.cursor)
        return first().concat(x, y);
      return struct({
        input: first(),
        fatal: first(),
        expected: getMonoid()
      }).concat(x, y);
    }
  };
};

// node_modules/parser-ts/es6/Stream.js
var stream = function(buffer, cursor) {
  if (cursor === void 0) {
    cursor = 0;
  }
  return {
    buffer,
    cursor
  };
};
var get = function(s) {
  return lookup2(s.cursor, s.buffer);
};
var atEnd = function(s) {
  return s.cursor >= s.buffer.length;
};
var getAndNext = function(s) {
  return pipe(get(s), map3(function(a) {
    return { value: a, next: { buffer: s.buffer, cursor: s.cursor + 1 } };
  }));
};

// node_modules/parser-ts/es6/Parser.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var succeed = function(a) {
  return function(i) {
    return success(a, i, i);
  };
};
var fail = function() {
  return function(i) {
    return error(i);
  };
};
var failAt = function(i) {
  return function() {
    return error(i);
  };
};
var sat = function(predicate) {
  return pipe(withStart(item()), chain3(function(_a) {
    var a = _a[0], start = _a[1];
    return predicate(a) ? of3(a) : failAt(start);
  }));
};
var expected = function(p2, message) {
  return function(i) {
    return pipe(p2(i), mapLeft(function(err) {
      return withExpected(err, [message]);
    }));
  };
};
var item = function() {
  return function(i) {
    return pipe(getAndNext(i), fold2(function() {
      return error(i);
    }, function(_a) {
      var value = _a.value, next = _a.next;
      return success(value, next, i);
    }));
  };
};
var seq = function(fa, f2) {
  return function(i) {
    return pipe(fa(i), chain(function(s) {
      return pipe(f2(s.value)(s.next), chain(function(next) {
        return success(next.value, next.next, i);
      }));
    }));
  };
};
var either = function(p2, f2) {
  return function(i) {
    var e = p2(i);
    if (isRight2(e)) {
      return e;
    }
    if (e.left.fatal) {
      return e;
    }
    return pipe(f2()(i), mapLeft(function(err) {
      return extend(e.left, err);
    }));
  };
};
var withStart = function(p2) {
  return function(i) {
    return pipe(p2(i), map(function(s) {
      return __assign2(__assign2({}, s), { value: [s.value, i] });
    }));
  };
};
var maybe = function(M) {
  return alt(function() {
    return of3(M.empty);
  });
};
var eof = function() {
  return expected(function(i) {
    return atEnd(i) ? success(void 0, i, i) : error(i);
  }, "end of file");
};
var many = function(p2) {
  return pipe(many1(p2), alt(function() {
    return of3([]);
  }));
};
var many1 = function(parser) {
  return pipe(parser, chain3(function(head5) {
    return chainRec_(of2(head5), function(acc) {
      return pipe(parser, map5(function(a) {
        return left2(append4(a)(acc));
      }), alt(function() {
        return of3(right2(acc));
      }));
    });
  }));
};
var sepBy = function(sep, p2) {
  var nil = of3([]);
  return pipe(sepBy1(sep, p2), alt(function() {
    return nil;
  }));
};
var sepBy1 = function(sep, p2) {
  return pipe(p2, chain3(function(head5) {
    return pipe(many(pipe(sep, apSecond(p2))), map5(function(tail4) {
      return prepend3(head5)(tail4);
    }));
  }));
};
var between = function(left3, right3) {
  return function(p2) {
    return pipe(left3, chain3(function() {
      return p2;
    }), chainFirst(function() {
      return right3;
    }));
  };
};
var surroundedBy = function(bound) {
  return between(bound, bound);
};
var lookAhead = function(p2) {
  return function(i) {
    return pipe(p2(i), chain(function(next) {
      return success(next.value, i, i);
    }));
  };
};
var optional2 = function(parser) {
  return pipe(parser, map5(some3), alt(function() {
    return succeed(none2);
  }));
};
var many1Till = function(parser, terminator) {
  return pipe(parser, chain3(function(x) {
    return chainRec_(of(x), function(acc) {
      return pipe(terminator, map5(function() {
        return right2(acc);
      }), alt(function() {
        return pipe(parser, map5(function(a) {
          return left2(append3(a)(acc));
        }));
      }));
    });
  }));
};
var map_ = function(ma, f2) {
  return function(i) {
    return pipe(ma(i), map(function(s) {
      return __assign2(__assign2({}, s), { value: f2(s.value) });
    }));
  };
};
var ap_ = function(mab, ma) {
  return chain_(mab, function(f2) {
    return map_(ma, f2);
  });
};
var chain_ = function(ma, f2) {
  return seq(ma, f2);
};
var chainRec_ = function(a, f2) {
  var split2 = function(start) {
    return function(result) {
      return isLeft2(result.value) ? left2({ value: result.value.left, stream: result.next }) : right2(success(result.value.right, result.next, start));
    };
  };
  return function(start) {
    return tailRec({ value: a, stream: start }, function(state) {
      var result = f2(state.value)(state.stream);
      if (isLeft2(result)) {
        return right2(error(state.stream, result.left.expected, result.left.fatal));
      }
      return split2(start)(result.right);
    });
  };
};
var alt_ = function(fa, that) {
  return either(fa, that);
};
var map5 = function(f2) {
  return function(fa) {
    return map_(fa, f2);
  };
};
var apFirst = function(fb) {
  return function(fa) {
    return ap_(map_(fa, function(a) {
      return function() {
        return a;
      };
    }), fb);
  };
};
var apSecond = function(fb) {
  return function(fa) {
    return ap_(map_(fa, function() {
      return function(b) {
        return b;
      };
    }), fb);
  };
};
var of3 = succeed;
var chain3 = function(f2) {
  return function(ma) {
    return chain_(ma, f2);
  };
};
var chainFirst = function(f2) {
  return function(ma) {
    return chain_(ma, function(a) {
      return map_(f2(a), function() {
        return a;
      });
    });
  };
};
var alt = function(that) {
  return function(fa) {
    return alt_(fa, that);
  };
};
var URI4 = "Parser";
var getSemigroup4 = function(S) {
  return {
    concat: function(x, y) {
      return ap_(map_(x, function(x2) {
        return function(y2) {
          return S.concat(x2, y2);
        };
      }), y);
    }
  };
};
var getMonoid3 = function(M) {
  return __assign2(__assign2({}, getSemigroup4(M)), { empty: succeed(M.empty) });
};
var ChainRec = {
  URI: URI4,
  map: map_,
  ap: ap_,
  chain: chain_,
  chainRec: chainRec_
};

// node_modules/parser-ts/es6/char.js
var maybe2 = maybe(Monoid);
var char = function(c) {
  return expected(sat(function(s) {
    return s === c;
  }), '"'.concat(c, '"'));
};
var notChar = function(c) {
  return expected(sat(function(c1) {
    return c1 !== c;
  }), 'anything but "'.concat(c, '"'));
};
var many2 = function(parser) {
  return maybe2(many12(parser));
};
var many12 = function(parser) {
  return pipe(many1(parser), map5(function(nea) {
    return nea.join("");
  }));
};
var isDigit = function(c) {
  return "0123456789".indexOf(c) !== -1;
};
var digit = expected(sat(isDigit), "a digit");
var spaceRe = /^\s$/;
var isSpace = function(c) {
  return spaceRe.test(c);
};
var space2 = expected(sat(isSpace), "a whitespace");
var isUnderscore = function(c) {
  return c === "_";
};
var isLetter = function(c) {
  return /[a-z]/.test(c.toLowerCase());
};
var isAlphanum = function(c) {
  return isLetter(c) || isDigit(c) || isUnderscore(c);
};
var alphanum = expected(sat(isAlphanum), "a word character");
var letter = expected(sat(isLetter), "a letter");
var isUnicodeLetter = function(c) {
  return c.toLowerCase() !== c.toUpperCase();
};
var unicodeLetter = expected(sat(isUnicodeLetter), "an unicode letter");
var isUpper = function(c) {
  return isLetter(c) && c === c.toUpperCase();
};
var upper = expected(sat(isUpper), "an upper case letter");
var isLower = function(c) {
  return isLetter(c) && c === c.toLowerCase();
};
var lower = expected(sat(isLower), "a lower case letter");
var notDigit = expected(sat(not(isDigit)), "a non-digit");
var notSpace = expected(sat(not(isSpace)), "a non-whitespace character");
var notAlphanum = expected(sat(not(isAlphanum)), "a non-word character");
var notLetter = expected(sat(not(isLetter)), "a non-letter character");
var notUpper = expected(sat(not(isUpper)), "anything but an upper case letter");
var notLower = expected(sat(not(isLower)), "anything but a lower case letter");

// node_modules/fp-ts/es6/Monoid.js
var concatAll3 = function(M) {
  return concatAll2(M)(M.empty);
};
var monoidVoid = {
  concat: semigroupVoid.concat,
  empty: void 0
};
var monoidAll = {
  concat: semigroupAll.concat,
  empty: true
};
var monoidAny = {
  concat: semigroupAny.concat,
  empty: false
};
var monoidString = {
  concat: semigroupString.concat,
  empty: ""
};
var monoidSum = {
  concat: semigroupSum.concat,
  empty: 0
};
var monoidProduct = {
  concat: semigroupProduct.concat,
  empty: 1
};

// node_modules/parser-ts/es6/string.js
var string2 = function(s) {
  return expected(ChainRec.chainRec(s, function(acc) {
    return pipe(charAt(0, acc), fold2(function() {
      return of3(right2(s));
    }, function(c) {
      return pipe(char(c), chain3(function() {
        return of3(left2(acc.slice(1)));
      }));
    }));
  }), JSON.stringify(s));
};
var fold3 = concatAll3(getMonoid3(Monoid));
var maybe3 = maybe(Monoid);
var many3 = function(parser) {
  return maybe3(many13(parser));
};
var many13 = function(parser) {
  return pipe(many1(parser), map5(function(nea) {
    return nea.join("");
  }));
};
var charAt = function(index, s) {
  return index >= 0 && index < s.length ? some3(s.charAt(index)) : none2;
};
var spaces = many2(space2);
var spaces1 = many12(space2);
var notSpaces = many2(notSpace);
var notSpaces1 = many12(notSpace);
var fromString = function(s) {
  var n = +s;
  return isNaN(n) || s === "" ? none2 : some3(n);
};
var int = expected(pipe(fold3([maybe3(char("-")), many12(digit)]), map5(function(s) {
  return +s;
})), "an integer");
var float = expected(pipe(fold3([maybe3(char("-")), many2(digit), maybe3(fold3([char("."), many12(digit)]))]), chain3(function(s) {
  return pipe(fromString(s), fold2(function() {
    return fail();
  }, succeed));
})), "a float");
var doubleQuotedString = surroundedBy(char('"'))(many3(either(string2('\\"'), function() {
  return notChar('"');
})));
function run2(string3) {
  return function(p2) {
    return p2(stream(string3.split("")));
  };
}

// src/core/template/templateParser.ts
var import_function13 = __toESM(require_function());
var import_obsidian12 = require("obsidian");
function TemplateText(value) {
  return { _tag: "text", value };
}
function TemplateVariable(value) {
  return { _tag: "variable", value };
}
function FrontmatterCommand(pick = [], omit = []) {
  return { _tag: "frontmatter-command", pick, omit };
}
var EofStr = pipe2(
  eof(),
  map5(() => "")
);
var open = fold3([string2("{{"), spaces]);
var close = expected(
  fold3([spaces, string2("}}")]),
  'closing variable tag: "}}"'
);
var identifier = many13(alphanum);
var templateIdentifier = pipe2(
  identifier,
  between(open, close),
  map5(TemplateVariable)
);
var commandOpen = fold3([string2("{#"), spaces]);
var commandClose = expected(
  fold3([spaces, string2("#}")]),
  'a closing command tag: "#}"'
);
var sepByComma = sepBy(fold3([char(","), spaces]), identifier);
var commandOptionParser = (option) => pipe2(
  fold3([string2(option), spaces]),
  apSecond(sepByComma)
);
var frontmatterCommandParser = pipe2(
  fold3([string2("frontmatter"), spaces]),
  apSecond(optional2(commandOptionParser("pick:")))
  //P.apFirst(S.spaces),
  // P.chain(commandOptionParser("pick:")),
);
var commandParser = pipe2(
  frontmatterCommandParser,
  between(commandOpen, commandClose),
  map5((value) => {
    return pipe2(
      value,
      O.fold(() => [], import_function13.identity),
      FrontmatterCommand
    );
  })
);
var OpenOrEof = pipe2(
  open,
  alt(() => commandOpen),
  alt(() => EofStr)
);
var anythingUntilOpenOrEOF = many1Till(
  item(),
  lookAhead(OpenOrEof)
);
var text2 = pipe2(
  anythingUntilOpenOrEOF,
  map5((value) => TemplateText(value.join("")))
);
var TextOrVariable = pipe2(
  templateIdentifier,
  alt(() => commandParser),
  alt(() => text2)
);
var Template = pipe2(
  many(TextOrVariable),
  apFirst(eof())
);
function parseTemplate(template) {
  return pipe2(
    Template,
    run2(template),
    fold(
      ({ expected: expected2 }) => left2(`Expected ${expected2.join(" or ")}`),
      (result) => right2(result.value)
    )
  );
}
function templateVariables(parsedTemplate) {
  return pipe2(
    parsedTemplate,
    fold(
      () => [],
      filterMap((token) => {
        if (token._tag === "variable") {
          return O.some(token.value);
        }
        return O.none;
      })
    )
  );
}
function templateError(parsedTemplate) {
  return pipe2(
    parsedTemplate,
    fold(
      (error2) => error2,
      () => void 0
    )
  );
}
function tokenToString(token) {
  const tag = token._tag;
  switch (tag) {
    case "text":
      return token.value;
    case "variable":
      return `{{${token.value}}}`;
    case "frontmatter-command":
      return `{{# frontmatter pick: ${token.pick.join(", ")}, omit: ${token.omit.join(", ")} #}}`;
    default:
      return (0, import_function13.absurd)(tag);
  }
}
function matchToken(onText, onVariable, onCommand) {
  return (token) => {
    switch (token._tag) {
      case "text":
        return onText(token.value);
      case "variable":
        return onVariable(token.value);
      case "frontmatter-command":
        return onCommand(token);
      default:
        return (0, import_function13.absurd)(token);
    }
  };
}
function parsedTemplateToString(parsedTemplate) {
  return pipe2(
    parsedTemplate,
    foldMap2(Monoid)(tokenToString)
  );
}
function asFrontmatterString(data) {
  return ({ pick, omit }) => pipe2(
    data,
    filterMapWithIndex3((key, value) => {
      if (pick.length === 0)
        return O.some(value);
      return pick.includes(key) ? O.some(value) : O.none;
    }),
    filterMapWithIndex3((key, value) => !omit.includes(key) ? O.some(value) : O.none),
    import_obsidian12.stringifyYaml
  );
}
function executeTemplate(parsedTemplate, formData) {
  const toFrontmatter = asFrontmatterString(formData);
  return pipe2(
    parsedTemplate,
    filterMap(matchToken(
      O.some,
      (key) => O.fromNullable(formData[key]),
      (command) => pipe2(
        command,
        toFrontmatter,
        O.some
      )
    )),
    foldMap2(Monoid)(String)
  );
}

// src/views/components/Code.svelte
function add_css4(target) {
  append_styles(target, "svelte-2knzul", "pre.svelte-2knzul{background-color:var(--background-secondary);border-radius:var(--border-radius);padding:0.5rem}code.svelte-2knzul{font-family:var(--font-family-monospace)}div.svelte-2knzul{display:flex}");
}
function create_fragment7(ctx) {
  let div;
  let pre;
  let code;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  return {
    c() {
      div = element("div");
      pre = element("pre");
      code = element("code");
      if (default_slot)
        default_slot.c();
      attr(code, "class", "svelte-2knzul");
      attr(pre, "class", "svelte-2knzul");
      attr(div, "class", "svelte-2knzul");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, pre);
      append5(pre, code);
      if (default_slot) {
        default_slot.m(code, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Code = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance7, create_fragment7, safe_not_equal, {}, add_css4);
  }
};
var Code_default = Code;

// src/views/components/TemplateEditor.svelte
function add_css5(target) {
  append_styles(target, "svelte-1daddci", ".fields-list.svelte-1daddci{padding-top:1rem}textarea.svelte-1daddci{font-family:var(--font-family-monospace);width:100%}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_default_slot_12(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*exampleText*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block3(ctx) {
  let li;
  let code;
  let t0_value = (
    /*field*/
    ctx[11] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*usedVariables*/
    ctx[4].includes(
      /*field*/
      ctx[11]
    ) ? "\u2705" : ""
  );
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append5(li, code);
      append5(code, t0);
      append5(li, t1);
      append5(li, t2);
      append5(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*fieldNames*/
      4 && t0_value !== (t0_value = /*field*/
      ctx2[11] + ""))
        set_data(t0, t0_value);
      if (dirty & /*usedVariables, fieldNames*/
      20 && t2_value !== (t2_value = /*usedVariables*/
      ctx2[4].includes(
        /*field*/
        ctx2[11]
      ) ? "\u2705" : ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block2(ctx) {
  let div1;
  let div0;
  let t1;
  let code;
  let current;
  code = new Code_default({
    props: {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "The template is invalid:";
      t1 = space();
      create_component(code.$$.fragment);
      attr(div0, "class", "invalid");
      attr(div1, "class", "error-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, div0);
      append5(div1, t1);
      mount_component(code, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const code_changes = {};
      if (dirty & /*$$scope, templateErrorMessage*/
      16392) {
        code_changes.$$scope = { dirty, ctx: ctx2 };
      }
      code.$set(code_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(code.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(code.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(code);
    }
  };
}
function create_default_slot3(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*templateErrorMessage*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*templateErrorMessage*/
      8)
        set_data(
          t,
          /*templateErrorMessage*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_fragment8(ctx) {
  let h6;
  let t0;
  let t1;
  let t2;
  let p2;
  let t3;
  let code0;
  let t5;
  let t6;
  let div1;
  let div0;
  let t8;
  let code1;
  let t9;
  let button;
  let t10;
  let button_disabled_value;
  let t11;
  let div2;
  let t12;
  let ul;
  let t13;
  let textarea;
  let textarea_rows_value;
  let t14;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  code1 = new Code_default({
    props: {
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*fieldNames*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  let if_block = (
    /*templateErrorMessage*/
    ctx[3] && create_if_block2(ctx)
  );
  return {
    c() {
      h6 = element("h6");
      t0 = text("Template for ");
      t1 = text(
        /*formName*/
        ctx[1]
      );
      t2 = space();
      p2 = element("p");
      t3 = text("Templates are used when you create a note directly from a form. You can put\n    any text you want and reference the form fields using the ");
      code0 = element("code");
      code0.textContent = `${`{{name}}`}`;
      t5 = text("\n    syntax.");
      t6 = space();
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "For example:";
      t8 = space();
      create_component(code1.$$.fragment);
      t9 = space();
      button = element("button");
      t10 = text("Save template");
      t11 = space();
      div2 = element("div");
      t12 = text("Available fields:\n    ");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t13 = space();
      textarea = element("textarea");
      t14 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
      attr(button, "class", "btn btn-primary");
      button.disabled = button_disabled_value = !!/*templateErrorMessage*/
      ctx[3];
      attr(div2, "class", "fields-list svelte-1daddci");
      attr(textarea, "rows", textarea_rows_value = 10);
      attr(textarea, "class", "form-control svelte-1daddci");
      attr(textarea, "placeholder", "Enter template here");
    },
    m(target, anchor) {
      insert(target, h6, anchor);
      append5(h6, t0);
      append5(h6, t1);
      insert(target, t2, anchor);
      insert(target, p2, anchor);
      append5(p2, t3);
      append5(p2, code0);
      append5(p2, t5);
      insert(target, t6, anchor);
      insert(target, div1, anchor);
      append5(div1, div0);
      append5(div1, t8);
      mount_component(code1, div1, null);
      insert(target, t9, anchor);
      insert(target, button, anchor);
      append5(button, t10);
      insert(target, t11, anchor);
      insert(target, div2, anchor);
      append5(div2, t12);
      append5(div2, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      insert(target, t13, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*templateString*/
        ctx[0]
      );
      insert(target, t14, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*handleSave*/
            ctx[6]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*formName*/
      2)
        set_data(
          t1,
          /*formName*/
          ctx2[1]
        );
      const code1_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        code1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      code1.$set(code1_changes);
      if (!current || dirty & /*templateErrorMessage*/
      8 && button_disabled_value !== (button_disabled_value = !!/*templateErrorMessage*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*usedVariables, fieldNames*/
      20) {
        each_value = ensure_array_like(
          /*fieldNames*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*templateString*/
      1) {
        set_input_value(
          textarea,
          /*templateString*/
          ctx2[0]
        );
      }
      if (
        /*templateErrorMessage*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*templateErrorMessage*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(code1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(code1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h6);
        detach(t2);
        detach(p2);
        detach(t6);
        detach(div1);
        detach(t9);
        detach(button);
        detach(t11);
        detach(div2);
        detach(t13);
        detach(textarea);
        detach(t14);
        detach(if_block_anchor);
      }
      destroy_component(code1);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let parsedTemplate;
  let usedVariables;
  let templateErrorMessage;
  let { templateString } = $$props;
  let { formName } = $$props;
  let { fieldNames } = $$props;
  let { saveTemplate } = $$props;
  const firstField = fieldNames[0];
  const exampleText = `Example text {{${firstField}}}`;
  const handleSave = () => {
    pipe2(parsedTemplate, E.map(saveTemplate));
  };
  function textarea_input_handler() {
    templateString = this.value;
    $$invalidate(0, templateString);
  }
  $$self.$$set = ($$props2) => {
    if ("templateString" in $$props2)
      $$invalidate(0, templateString = $$props2.templateString);
    if ("formName" in $$props2)
      $$invalidate(1, formName = $$props2.formName);
    if ("fieldNames" in $$props2)
      $$invalidate(2, fieldNames = $$props2.fieldNames);
    if ("saveTemplate" in $$props2)
      $$invalidate(7, saveTemplate = $$props2.saveTemplate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*templateString*/
    1) {
      $:
        $$invalidate(8, parsedTemplate = parseTemplate(templateString));
    }
    if ($$self.$$.dirty & /*parsedTemplate*/
    256) {
      $:
        $$invalidate(4, usedVariables = templateVariables(parsedTemplate));
    }
    if ($$self.$$.dirty & /*parsedTemplate*/
    256) {
      $:
        $$invalidate(3, templateErrorMessage = templateError(parsedTemplate));
    }
  };
  return [
    templateString,
    formName,
    fieldNames,
    templateErrorMessage,
    usedVariables,
    exampleText,
    handleSave,
    saveTemplate,
    parsedTemplate,
    textarea_input_handler
  ];
}
var TemplateEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        templateString: 0,
        formName: 1,
        fieldNames: 2,
        saveTemplate: 7
      },
      add_css5
    );
  }
};
var TemplateEditor_default = TemplateEditor;

// src/views/FormBuilder.svelte
var import_function14 = __toESM(require_function());

// src/views/components/Tabs.svelte
function add_css6(target) {
  append_styles(target, "svelte-1uurynp", '.tabs.svelte-1uurynp{display:flex;flex-direction:row;justify-content:flex-start;padding-top:0.15rem}.tab.svelte-1uurynp{background:none;cursor:pointer;font-size:1rem;color:var(--gray-700);border:none;outline:none;cursor:pointer;padding:1rem;border-radius:10px 10px 0 0;box-shadow:none;text-transform:capitalize;position:relative}.tab.svelte-1uurynp::after{position:absolute;right:-0.5px;width:1px;background-color:var(--tab-divider-color);content:" ";height:20px}button.svelte-1uurynp{appearance:none;border:none}.tab-outer.svelte-1uurynp{padding:1px 0px 3.5px;border-radius:var(--tab-radius-active)}.tab-outer.active.svelte-1uurynp{color:var(--tab-text-color-focused-active);background-color:var(--tab-background-active)}.tabs.svelte-1uurynp{background-color:var(--background-secondary)}.tab-outer.svelte-1uurynp:hover{background-color:var(--background-modifier-border) !important}');
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let div;
  let button;
  let t0_value = (
    /*tab*/
    ctx[3] + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[2](
        /*tab*/
        ctx[3]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr(button, "class", "tab svelte-1uurynp");
      attr(div, "class", "tab-outer svelte-1uurynp");
      toggle_class(
        div,
        "active",
        /*tab*/
        ctx[3] === /*activeTab*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, button);
      append5(button, t0);
      append5(div, t1);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      2 && t0_value !== (t0_value = /*tab*/
      ctx[3] + ""))
        set_data(t0, t0_value);
      if (dirty & /*tabs, activeTab*/
      3) {
        toggle_class(
          div,
          "active",
          /*tab*/
          ctx[3] === /*activeTab*/
          ctx[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tabs svelte-1uurynp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabs, activeTab*/
      3) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { activeTab } = $$props;
  let { tabs } = $$props;
  const click_handler = (tab) => {
    $$invalidate(0, activeTab = tab);
  };
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab = $$props2.activeTab);
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*activeTab*/
    1) {
      $:
        console.log(activeTab);
    }
  };
  return [activeTab, tabs, click_handler];
}
var Tabs = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance9, create_fragment9, safe_not_equal, { activeTab: 0, tabs: 1 }, add_css6);
  }
};
var Tabs_default = Tabs;

// src/views/FormBuilder.svelte
function add_css7(target) {
  append_styles(target, "svelte-eyf10e", ".wrapper.svelte-eyf10e,.body.svelte-eyf10e{flex:1;display:flex;flex-direction:column}.wrapper.svelte-eyf10e{max-height:100%;min-height:100%;height:100%;overflow:hidden}.body.svelte-eyf10e{padding-top:0.5rem;overflow-y:scroll}.header.svelte-eyf10e{box-shadow:var(--shadow-bottom) var(--divider-color);padding:1rem}@media(min-width: 58rem){.body.svelte-eyf10e{overflow-y:hidden}.fields.svelte-eyf10e{flex:1;height:100%}form.svelte-eyf10e{display:flex;flex-direction:column;height:100%;overflow:hidden}}.template.svelte-eyf10e{padding:1rem}.fields.svelte-eyf10e{overflow-y:auto;padding:1rem}.flex.svelte-eyf10e{display:flex}.column.svelte-eyf10e{flex-direction:column}.gap1.svelte-eyf10e{gap:0.5rem}.gap2.svelte-eyf10e{gap:1rem}fieldset.svelte-eyf10e{border:none;padding:0}.hint.svelte-eyf10e{color:var(--color-base-70)}.error.svelte-eyf10e{color:var(--text-error);font-weight:bold}button.svelte-eyf10e:disabled{opacity:0.5;cursor:forbidden}@media(min-width: 58rem){.md-row.svelte-eyf10e{flex-direction:row}}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  child_ctx[45] = list;
  child_ctx[46] = i;
  const constants_0 = `desc_${/*index*/
  child_ctx[46]}`;
  child_ctx[43] = constants_0;
  const constants_1 = `delete_${/*index*/
  child_ctx[46]}`;
  child_ctx[44] = constants_1;
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `min_${/*index*/
  child_ctx[46]}`;
  child_ctx[47] = constants_0;
  const constants_1 = `max_${/*index*/
  child_ctx[46]}`;
  child_ctx[48] = constants_1;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[52] = list[i];
  return child_ctx;
}
function create_else_block3(ctx) {
  let form;
  let fieldset0;
  let label0;
  let t1;
  let span0;
  let t3;
  let input0;
  let t4;
  let label1;
  let t6;
  let span1;
  let t8;
  let input1;
  let t9;
  let label2;
  let span2;
  let input2;
  let t12;
  let div;
  let button0;
  let t14;
  let button1;
  let t15;
  let button1_disabled_value;
  let t16;
  let button2;
  let t17;
  let button2_disabled_value;
  let t18;
  let button3;
  let t20;
  let t21;
  let fieldset1;
  let h3;
  let t23;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*errors*/
    ctx[6].length > 0 && create_if_block_8(ctx)
  );
  const if_block_creators = [create_if_block_12, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*definition*/
      ctx2[0].fields.length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      form = element("form");
      fieldset0 = element("fieldset");
      label0 = element("label");
      label0.textContent = "Form unique name";
      t1 = space();
      span0 = element("span");
      span0.textContent = "This name will identify this form uniquely, and will be\n                        the value you need to provide when calling the method\n                        openForm";
      t3 = space();
      input0 = element("input");
      t4 = space();
      label1 = element("label");
      label1.textContent = "Form title";
      t6 = space();
      span1 = element("span");
      span1.textContent = "This is the title that will be shown in the modal when\n                        the form is visible";
      t8 = space();
      input1 = element("input");
      t9 = space();
      label2 = element("label");
      label2.textContent = "Custom class Name";
      span2 = element("span");
      span2.textContent = "In case you want to add a class name to the modal form\n                        to customize it";
      input2 = element("input");
      t12 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Add more fields";
      t14 = space();
      button1 = element("button");
      t15 = text("Preview");
      t16 = space();
      button2 = element("button");
      t17 = text("Save and close");
      t18 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      t20 = space();
      if (if_block0)
        if_block0.c();
      t21 = space();
      fieldset1 = element("fieldset");
      h3 = element("h3");
      h3.textContent = "Fields";
      t23 = space();
      if_block1.c();
      attr(label0, "for", "name");
      attr(span0, "class", "hint svelte-eyf10e");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", "name");
      attr(label1, "for", "title");
      attr(span1, "class", "hint svelte-eyf10e");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Title");
      attr(input1, "id", "title");
      attr(label2, "for", "customClassname");
      attr(span2, "class", "hint svelte-eyf10e");
      attr(input2, "type", "text");
      attr(input2, "id", "customClassname");
      attr(button0, "type", "button");
      attr(button0, "class", "svelte-eyf10e");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = !/*isValid*/
      ctx[7];
      attr(button1, "class", "svelte-eyf10e");
      attr(button2, "class", "mod-cta svelte-eyf10e");
      attr(button2, "type", "submit");
      button2.disabled = button2_disabled_value = !/*isValid*/
      ctx[7];
      attr(button3, "type", "button");
      attr(button3, "class", "mod-warning svelte-eyf10e");
      attr(div, "class", "flex row gap2 svelte-eyf10e");
      attr(fieldset0, "class", "flex column gap2 header svelte-eyf10e");
      attr(fieldset1, "class", "flex column gap2 fields svelte-eyf10e");
      attr(form, "class", "svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append5(form, fieldset0);
      append5(fieldset0, label0);
      append5(fieldset0, t1);
      append5(fieldset0, span0);
      append5(fieldset0, t3);
      append5(fieldset0, input0);
      set_input_value(
        input0,
        /*definition*/
        ctx[0].name
      );
      append5(fieldset0, t4);
      append5(fieldset0, label1);
      append5(fieldset0, t6);
      append5(fieldset0, span1);
      append5(fieldset0, t8);
      append5(fieldset0, input1);
      set_input_value(
        input1,
        /*definition*/
        ctx[0].title
      );
      append5(fieldset0, t9);
      append5(fieldset0, label2);
      append5(fieldset0, span2);
      append5(fieldset0, input2);
      set_input_value(
        input2,
        /*definition*/
        ctx[0].customClassname
      );
      append5(fieldset0, t12);
      append5(fieldset0, div);
      append5(div, button0);
      append5(div, t14);
      append5(div, button1);
      append5(button1, t15);
      append5(div, t16);
      append5(div, button2);
      append5(button2, t17);
      append5(div, t18);
      append5(div, button3);
      append5(fieldset0, t20);
      if (if_block0)
        if_block0.m(fieldset0, null);
      append5(form, t21);
      append5(form, fieldset1);
      append5(fieldset1, h3);
      append5(fieldset1, t23);
      if_blocks[current_block_type_index].m(fieldset1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[16]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[17]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[18]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[19]
          ),
          listen(
            button1,
            "click",
            /*handlePreview*/
            ctx[12]
          ),
          listen(button3, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(
            /*handleSubmit*/
            ctx[10]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*definition*/
      ctx[0].name) {
        set_input_value(
          input0,
          /*definition*/
          ctx[0].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*definition*/
      ctx[0].title) {
        set_input_value(
          input1,
          /*definition*/
          ctx[0].title
        );
      }
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*definition*/
      ctx[0].customClassname) {
        set_input_value(
          input2,
          /*definition*/
          ctx[0].customClassname
        );
      }
      if (!current || dirty[0] & /*isValid*/
      128 && button1_disabled_value !== (button1_disabled_value = !/*isValid*/
      ctx[7])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & /*isValid*/
      128 && button2_disabled_value !== (button2_disabled_value = !/*isValid*/
      ctx[7])) {
        button2.disabled = button2_disabled_value;
      }
      if (
        /*errors*/
        ctx[6].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_8(ctx);
          if_block0.c();
          if_block0.m(fieldset0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(fieldset1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block3(ctx) {
  let div;
  let templateeditor;
  let current;
  templateeditor = new TemplateEditor_default({
    props: {
      formName: (
        /*definition*/
        ctx[0].name
      ),
      fieldNames: (
        /*fieldNames*/
        ctx[5]
      ),
      saveTemplate: (
        /*saveTemplate*/
        ctx[11]
      ),
      templateString: (
        /*definition*/
        ctx[0].template ? parsedTemplateToString(
          /*definition*/
          ctx[0].template.parsedTemplate
        ) : ""
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(templateeditor.$$.fragment);
      attr(div, "class", "template svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(templateeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const templateeditor_changes = {};
      if (dirty[0] & /*definition*/
      1)
        templateeditor_changes.formName = /*definition*/
        ctx2[0].name;
      if (dirty[0] & /*fieldNames*/
      32)
        templateeditor_changes.fieldNames = /*fieldNames*/
        ctx2[5];
      if (dirty[0] & /*definition*/
      1)
        templateeditor_changes.templateString = /*definition*/
        ctx2[0].template ? parsedTemplateToString(
          /*definition*/
          ctx2[0].template.parsedTemplate
        ) : "";
      templateeditor.$set(templateeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(templateeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(templateeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(templateeditor);
    }
  };
}
function create_if_block_8(ctx) {
  let h3;
  let t2;
  let ul;
  let each_value_2 = ensure_array_like(
    /*errors*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      h3 = element("h3");
      h3.innerHTML = `<span class="error svelte-eyf10e">Form is invalid</span>, check
                            the following:`;
      t2 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(h3, "margin", "0");
      set_style(ul, "margin", "0");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*activeFieldIndex, errors*/
      80) {
        each_value_2 = ensure_array_like(
          /*errors*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t2);
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let t0;
  let t1_value = (
    /*error*/
    ctx[52].path + ""
  );
  let t1;
  return {
    c() {
      t0 = text("at ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*errors*/
      64 && t1_value !== (t1_value = /*error*/
      ctx2[52].path + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let li;
  let t0_value = (
    /*error*/
    ctx[52].message + ""
  );
  let t0;
  let t1;
  let t2;
  let button;
  let t4;
  let mounted;
  let dispose;
  let if_block = (
    /*error*/
    ctx[52].path && create_if_block_9(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[20](
        /*error*/
        ctx[52]
      )
    );
  }
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      button = element("button");
      button.textContent = "Go to problem";
      t4 = space();
      attr(button, "type", "button");
      attr(button, "class", "svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append5(li, t0);
      append5(li, t1);
      if (if_block)
        if_block.m(li, null);
      append5(li, t2);
      append5(li, button);
      append5(li, t4);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*errors*/
      64 && t0_value !== (t0_value = /*error*/
      ctx[52].message + ""))
        set_data(t0, t0_value);
      if (
        /*error*/
        ctx[52].path
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_9(ctx);
          if_block.c();
          if_block.m(li, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("No fields yet");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*definition*/
    ctx[0].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty2();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*definition, duplicateField, moveField, onChange, activeFieldIndex*/
      787) {
        each_value = ensure_array_like(
          /*definition*/
          ctx2[0].fields
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Make required",
      id: `required_${/*index*/
      ctx[46]}`,
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty[0] & /*definition*/
      1 | dirty[1] & /*$$scope*/
      16777216) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot4(ctx) {
  let toggle;
  let updating_checked;
  let current;
  function toggle_checked_binding(value) {
    ctx[23](
      value,
      /*field*/
      ctx[42]
    );
  }
  let toggle_props = { tabindex: (
    /*index*/
    ctx[46]
  ) };
  if (
    /*field*/
    ctx[42].isRequired !== void 0
  ) {
    toggle_props.checked = /*field*/
    ctx[42].isRequired;
  }
  toggle = new Toggle_default({ props: toggle_props });
  binding_callbacks.push(() => bind2(toggle, "checked", toggle_checked_binding));
  return {
    c() {
      create_component(toggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toggle, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const toggle_changes = {};
      if (!updating_checked && dirty[0] & /*definition*/
      1) {
        updating_checked = true;
        toggle_changes.checked = /*field*/
        ctx[42].isRequired;
        add_flush_callback(() => updating_checked = false);
      }
      toggle.$set(toggle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let option;
  let t_value = (
    /*type*/
    ctx[49][1] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*type*/
      ctx[49][0];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append5(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[36](
      value,
      /*field*/
      ctx[42]
    );
  }
  let inputbuilderdataview_props = { index: (
    /*index*/
    ctx[46]
  ) };
  if (
    /*field*/
    ctx[42].input.query !== void 0
  ) {
    inputbuilderdataview_props.value = /*field*/
    ctx[42].input.query;
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderdataview_changes = {};
      if (!updating_value && dirty[0] & /*definition*/
      1) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*field*/
        ctx[42].input.query;
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[35](
      value,
      /*field*/
      ctx[42]
    );
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[46]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    )
  };
  if (
    /*field*/
    ctx[42].input.folder !== void 0
  ) {
    inputfolder_props.folder = /*field*/
    ctx[42].input.folder;
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputfolder_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputfolder_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputfolder_changes.folder = /*field*/
        ctx[42].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let mounted;
  let dispose;
  function input0_input_handler_2() {
    ctx[33].call(
      input0,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  function input1_input_handler_2() {
    ctx[34].call(
      input1,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  return {
    c() {
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Min";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Max";
      t4 = space();
      input1 = element("input");
      attr(label0, "for", label0_for_value = /*min_id*/
      ctx[47]);
      attr(input0, "type", "number");
      attr(input0, "placeholder", "0");
      attr(input0, "id", input0_id_value = /*min_id*/
      ctx[47]);
      attr(div0, "class", "flex column gap1 svelte-eyf10e");
      attr(label1, "for", label1_for_value = /*max_id*/
      ctx[48]);
      attr(input1, "type", "number");
      attr(input1, "placeholder", "10");
      attr(input1, "id", input1_id_value = /*max_id*/
      ctx[48]);
      attr(div1, "class", "flex column gap1 svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append5(div0, label0);
      append5(div0, t1);
      append5(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[42].input.min
      );
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append5(div1, label1);
      append5(div1, t4);
      append5(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[42].input.max
      );
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_2),
          listen(input1, "input", input1_input_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && to_number(input0.value) !== /*field*/
      ctx[42].input.min) {
        set_input_value(
          input0,
          /*field*/
          ctx[42].input.min
        );
      }
      if (dirty[0] & /*definition*/
      1 && to_number(input1.value) !== /*field*/
      ctx[42].input.max) {
        set_input_value(
          input1,
          /*field*/
          ctx[42].input.max
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_32(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let updating_query;
  let current;
  function inputbuilderselect_source_binding_1(value) {
    ctx[29](
      value,
      /*field*/
      ctx[42]
    );
  }
  function inputbuilderselect_options_binding_1(value) {
    ctx[30](
      value,
      /*field*/
      ctx[42]
    );
  }
  function inputbuilderselect_folder_binding_1(value) {
    ctx[31](
      value,
      /*field*/
      ctx[42]
    );
  }
  function inputbuilderselect_query_binding(value) {
    ctx[32](
      value,
      /*field*/
      ctx[42]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[46]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: true
  };
  if (
    /*field*/
    ctx[42].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[42].input.source;
  }
  if (
    /*field*/
    ctx[42].input.multi_select_options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[42].input.multi_select_options;
  }
  if (
    /*field*/
    ctx[42].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[42].input.folder;
  }
  if (
    /*field*/
    ctx[42].input.query !== void 0
  ) {
    inputbuilderselect_props.query = /*field*/
    ctx[42].input.query;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "query", inputbuilderselect_query_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[42].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[42].input.multi_select_options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[42].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      if (!updating_query && dirty[0] & /*definition*/
      1) {
        updating_query = true;
        inputbuilderselect_changes.query = /*field*/
        ctx[42].input.query;
        add_flush_callback(() => updating_query = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let current;
  function inputbuilderselect_source_binding(value) {
    ctx[26](
      value,
      /*field*/
      ctx[42]
    );
  }
  function inputbuilderselect_options_binding(value) {
    ctx[27](
      value,
      /*field*/
      ctx[42]
    );
  }
  function inputbuilderselect_folder_binding(value) {
    ctx[28](
      value,
      /*field*/
      ctx[42]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[46]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: false
  };
  if (
    /*field*/
    ctx[42].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[42].input.source;
  }
  if (
    /*field*/
    ctx[42].input.options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[42].input.options;
  }
  if (
    /*field*/
    ctx[42].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[42].input.folder;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[42].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[42].input.options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[42].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_each_block5(ctx) {
  let div3;
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let t5;
  let show_if = ["text", "email", "tel", "number", "note", "tag", "dataview", "multiselect"].includes(
    /*field*/
    ctx[42].input.type
  );
  let t6;
  let div2;
  let label2;
  let label2_for_value;
  let scrollWhenActive_action;
  let t9;
  let div6;
  let div4;
  let label3;
  let label3_for_value;
  let t11;
  let input2;
  let input2_id_value;
  let t12;
  let div5;
  let label4;
  let label4_for_value;
  let t14;
  let select;
  let select_id_value;
  let t15;
  let div7;
  let current_block_type_index;
  let if_block1;
  let t16;
  let div8;
  let button0;
  let button0_disabled_value;
  let setIcon_action;
  let t17;
  let button1;
  let button1_disabled_value;
  let setIcon_action_1;
  let t18;
  let button2;
  let t20;
  let button3;
  let button3_id_value;
  let setIcon_action_2;
  let t21;
  let hr;
  let current;
  let mounted;
  let dispose;
  function input0_input_handler_1() {
    ctx[21].call(
      input0,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  function input1_input_handler_1() {
    ctx[22].call(
      input1,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  let if_block0 = show_if && create_if_block_7(ctx);
  function input2_input_handler_1() {
    ctx[24].call(
      input2,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  let each_value_1 = ensure_array_like(Object.entries(FieldTypeReadable));
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[25].call(
      select,
      /*each_value*/
      ctx[45],
      /*index*/
      ctx[46]
    );
  }
  const if_block_creators = [
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_5,
    create_if_block_6
  ];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*field*/
      ctx2[42].input.type === "select"
    )
      return 0;
    if (
      /*field*/
      ctx2[42].input.type === "multiselect"
    )
      return 1;
    if (
      /*field*/
      ctx2[42].input.type === "slider"
    )
      return 2;
    if (
      /*field*/
      ctx2[42].input.type === "note"
    )
      return 3;
    if (
      /*field*/
      ctx2[42].input.type === "dataview"
    )
      return 4;
    return -1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 2)
      return get_if_ctx(ctx2);
    return ctx2;
  }
  if (~(current_block_type_index = select_block_type_2(ctx, [-1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[37](
        /*index*/
        ctx[46]
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[38](
        /*index*/
        ctx[46]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[39](
        /*index*/
        ctx[46]
      )
    );
  }
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[40](
        /*index*/
        ctx[46]
      )
    );
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Label";
      t4 = space();
      input1 = element("input");
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `delete ${/*index*/
      ctx[46]}`;
      t9 = space();
      div6 = element("div");
      div4 = element("div");
      label3 = element("label");
      label3.textContent = "Description";
      t11 = space();
      input2 = element("input");
      t12 = space();
      div5 = element("div");
      label4 = element("label");
      label4.textContent = "Type";
      t14 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t15 = space();
      div7 = element("div");
      if (if_block1)
        if_block1.c();
      t16 = space();
      div8 = element("div");
      button0 = element("button");
      t17 = space();
      button1 = element("button");
      t18 = space();
      button2 = element("button");
      button2.textContent = "Duplicate";
      t20 = space();
      button3 = element("button");
      t21 = space();
      hr = element("hr");
      attr(label0, "for", label0_for_value = `name_${/*index*/
      ctx[46]}`);
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", input0_id_value = `name_${/*index*/
      ctx[46]}`);
      attr(div0, "class", "flex column gap1 svelte-eyf10e");
      attr(label1, "for", label1_for_value = `label_${/*index*/
      ctx[46]}`);
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Label");
      attr(input1, "id", input1_id_value = `label_${/*index*/
      ctx[46]}`);
      attr(div1, "class", "flex column gap1 svelte-eyf10e");
      attr(label2, "for", label2_for_value = /*delete_id*/
      ctx[44]);
      set_style(label2, "visibility", "hidden");
      set_style(label2, "overflow", "hidden");
      set_style(label2, "white-space", "nowrap");
      attr(div2, "class", "flex column gap1 svelte-eyf10e");
      attr(div3, "class", "flex column md-row gap2 svelte-eyf10e");
      attr(label3, "for", label3_for_value = /*desc_id*/
      ctx[43]);
      attr(input2, "type", "text");
      attr(input2, "placeholder", "Description");
      attr(input2, "id", input2_id_value = /*desc_id*/
      ctx[43]);
      attr(div4, "class", "flex column gap1 svelte-eyf10e");
      attr(label4, "for", label4_for_value = `type_${/*index*/
      ctx[46]}`);
      attr(select, "id", select_id_value = `type_${/*index*/
      ctx[46]}`);
      if (
        /*field*/
        ctx[42].input.type === void 0
      )
        add_render_callback(select_change_handler);
      attr(div5, "class", "flex column gap1 svelte-eyf10e");
      attr(div6, "class", "flex column md-row gap2 svelte-eyf10e");
      attr(div7, "class", "flex gap1 svelte-eyf10e");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = /*index*/
      ctx[46] === 0;
      attr(button0, "class", "svelte-eyf10e");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = /*index*/
      ctx[46] === /*definition*/
      ctx[0].fields.length - 1;
      attr(button1, "class", "svelte-eyf10e");
      attr(button2, "type", "button");
      attr(button2, "class", "svelte-eyf10e");
      attr(button3, "type", "button");
      attr(button3, "id", button3_id_value = /*delete_id*/
      ctx[44]);
      attr(button3, "class", "svelte-eyf10e");
      attr(div8, "class", "flex gap1 svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append5(div3, div0);
      append5(div0, label0);
      append5(div0, t1);
      append5(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[42].name
      );
      append5(div3, t2);
      append5(div3, div1);
      append5(div1, label1);
      append5(div1, t4);
      append5(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[42].label
      );
      append5(div3, t5);
      if (if_block0)
        if_block0.m(div3, null);
      append5(div3, t6);
      append5(div3, div2);
      append5(div2, label2);
      insert(target, t9, anchor);
      insert(target, div6, anchor);
      append5(div6, div4);
      append5(div4, label3);
      append5(div4, t11);
      append5(div4, input2);
      set_input_value(
        input2,
        /*field*/
        ctx[42].description
      );
      append5(div6, t12);
      append5(div6, div5);
      append5(div5, label4);
      append5(div5, t14);
      append5(div5, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*field*/
        ctx[42].input.type,
        true
      );
      insert(target, t15, anchor);
      insert(target, div7, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div7, null);
      }
      insert(target, t16, anchor);
      insert(target, div8, anchor);
      append5(div8, button0);
      append5(div8, t17);
      append5(div8, button1);
      append5(div8, t18);
      append5(div8, button2);
      append5(div8, t20);
      append5(div8, button3);
      insert(target, t21, anchor);
      insert(target, hr, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_1),
          listen(input1, "input", input1_input_handler_1),
          action_destroyer(scrollWhenActive_action = scrollWhenActive.call(
            null,
            div3,
            /*index*/
            ctx[46] === /*activeFieldIndex*/
            ctx[4]
          )),
          listen(input2, "input", input2_input_handler_1),
          listen(select, "change", select_change_handler),
          action_destroyer(setIcon_action = import_obsidian13.setIcon.call(null, button0, "arrow-up")),
          listen(button0, "click", click_handler_2),
          action_destroyer(setIcon_action_1 = import_obsidian13.setIcon.call(null, button1, "arrow-down")),
          listen(button1, "click", click_handler_3),
          listen(button2, "click", click_handler_4),
          action_destroyer(setIcon_action_2 = import_obsidian13.setIcon.call(null, button3, "trash")),
          listen(button3, "click", click_handler_5)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*field*/
      ctx[42].name) {
        set_input_value(
          input0,
          /*field*/
          ctx[42].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*field*/
      ctx[42].label) {
        set_input_value(
          input1,
          /*field*/
          ctx[42].label
        );
      }
      if (dirty[0] & /*definition*/
      1)
        show_if = ["text", "email", "tel", "number", "note", "tag", "dataview", "multiselect"].includes(
          /*field*/
          ctx[42].input.type
        );
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*definition*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t6);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (scrollWhenActive_action && is_function(scrollWhenActive_action.update) && dirty[0] & /*activeFieldIndex*/
      16)
        scrollWhenActive_action.update.call(
          null,
          /*index*/
          ctx[46] === /*activeFieldIndex*/
          ctx[4]
        );
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*field*/
      ctx[42].description) {
        set_input_value(
          input2,
          /*field*/
          ctx[42].description
        );
      }
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(FieldTypeReadable));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*definition*/
      1) {
        select_option(
          select,
          /*field*/
          ctx[42].input.type
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(select_block_ctx(ctx, current_block_type_index), dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
            if_block1.c();
          } else {
            if_block1.p(select_block_ctx(ctx, current_block_type_index), dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div7, null);
        } else {
          if_block1 = null;
        }
      }
      if (!current || dirty[0] & /*definition*/
      1 && button1_disabled_value !== (button1_disabled_value = /*index*/
      ctx[46] === /*definition*/
      ctx[0].fields.length - 1)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t9);
        detach(div6);
        detach(t15);
        detach(div7);
        detach(t16);
        detach(div8);
        detach(t21);
        detach(hr);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment10(ctx) {
  let div1;
  let tabs;
  let updating_activeTab;
  let t;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  function tabs_activeTab_binding(value) {
    ctx[15](value);
  }
  let tabs_props = { tabs: ["form", "template"] };
  if (
    /*currentTab*/
    ctx[3] !== void 0
  ) {
    tabs_props.activeTab = /*currentTab*/
    ctx[3];
  }
  tabs = new Tabs_default({ props: tabs_props });
  binding_callbacks.push(() => bind2(tabs, "activeTab", tabs_activeTab_binding));
  const if_block_creators = [create_if_block3, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*currentTab*/
      ctx2[3] === "template"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      create_component(tabs.$$.fragment);
      t = space();
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "body svelte-eyf10e");
      attr(div1, "class", "wrapper modal-form svelte-eyf10e");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(tabs, div1, null);
      append5(div1, t);
      append5(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (!updating_activeTab && dirty[0] & /*currentTab*/
      8) {
        updating_activeTab = true;
        tabs_changes.activeTab = /*currentTab*/
        ctx2[3];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs.$set(tabs_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tabs.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(tabs);
      if_blocks[current_block_type_index].d();
    }
  };
}
function scrollWhenActive(element2, isActive) {
  function update3(isActive2) {
    if (isActive2) {
      setTimeout(
        () => {
          element2.scrollIntoView({ behavior: "smooth", block: "center" });
        },
        100
      );
    }
  }
  update3(isActive);
  return { update: update3 };
}
function instance10($$self, $$props, $$invalidate) {
  let isValid;
  let errors;
  let activeFieldIndex;
  let fieldNames;
  let { definition = {
    title: "",
    name: "",
    version: "1",
    fields: []
  } } = $$props;
  let { onChange } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let { onPreview } = $$props;
  let currentTab = "form";
  function findFreeName(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return Date.now() + "";
    }
    let name = field.name;
    const allNames = definition.fields.map((f2) => f2.name);
    let i = 1;
    while (allNames.includes(name)) {
      name = `${field.name}_${i}`;
      i++;
    }
    return name;
  }
  function duplicateField(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return;
    }
    const newField = Object.assign(Object.assign({}, field), {
      input: structuredClone(field.input),
      name: findFreeName(fieldIndex)
    });
    definition.fields.splice(fieldIndex + 1, 0, newField);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(4, activeFieldIndex = fieldIndex + 1);
  }
  function moveField(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= definition.fields.length)
      return;
    const tmp = definition.fields[from];
    const target = definition.fields[to];
    if (!target || !tmp)
      return;
    $$invalidate(0, definition.fields[from] = target, definition);
    $$invalidate(0, definition.fields[to] = tmp, definition);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(4, activeFieldIndex = to);
  }
  const handleSubmit = () => {
    if (!isValidFormDefinition(definition))
      return;
    onSubmit(definition);
  };
  function saveTemplate(parsedTemplate) {
    onSubmit(Object.assign(Object.assign({}, definition), {
      template: { parsedTemplate, createCommand: true }
    }));
  }
  const handlePreview = () => {
    if (!isValidFormDefinition(definition))
      return;
    console.log("preview of", definition);
    onPreview(definition);
  };
  function tabs_activeTab_binding(value) {
    currentTab = value;
    $$invalidate(3, currentTab);
  }
  function input0_input_handler() {
    definition.name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler() {
    definition.title = this.value;
    $$invalidate(0, definition);
  }
  function input2_input_handler() {
    definition.customClassname = this.value;
    $$invalidate(0, definition);
  }
  const click_handler = () => {
    $$invalidate(
      0,
      definition.fields = [
        ...definition.fields,
        {
          name: "",
          label: "",
          description: "",
          input: { type: "text" }
        }
      ],
      definition
    );
    $$invalidate(4, activeFieldIndex = definition.fields.length - 1);
  };
  const click_handler_1 = (error2) => {
    $$invalidate(4, activeFieldIndex = error2.index);
  };
  function input0_input_handler_1(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler_1(each_value, index) {
    each_value[index].label = this.value;
    $$invalidate(0, definition);
  }
  function toggle_checked_binding(value, field) {
    if ($$self.$$.not_equal(field.isRequired, value)) {
      field.isRequired = value;
      $$invalidate(0, definition);
    }
  }
  function input2_input_handler_1(each_value, index) {
    each_value[index].description = this.value;
    $$invalidate(0, definition);
  }
  function select_change_handler(each_value, index) {
    each_value[index].input.type = select_value(this);
    $$invalidate(0, definition);
  }
  function inputbuilderselect_source_binding(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding(value, field) {
    if ($$self.$$.not_equal(field.input.options, value)) {
      field.input.options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_source_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.multi_select_options, value)) {
      field.input.multi_select_options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_query_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  function input0_input_handler_2(each_value, index) {
    each_value[index].input.min = to_number(this.value);
    $$invalidate(0, definition);
  }
  function input1_input_handler_2(each_value, index) {
    each_value[index].input.max = to_number(this.value);
    $$invalidate(0, definition);
  }
  function inputfolder_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderdataview_value_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  const click_handler_2 = (index) => moveField(index, "up");
  const click_handler_3 = (index) => moveField(index, "down");
  const click_handler_4 = (index) => duplicateField(index);
  const click_handler_5 = (index) => {
    $$invalidate(0, definition.fields = definition.fields.filter((_, i) => i !== index), definition);
  };
  $$self.$$set = ($$props2) => {
    if ("definition" in $$props2)
      $$invalidate(0, definition = $$props2.definition);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("onSubmit" in $$props2)
      $$invalidate(13, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(2, onCancel = $$props2.onCancel);
    if ("onPreview" in $$props2)
      $$invalidate(14, onPreview = $$props2.onPreview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(7, isValid = isValidFormDefinition(definition));
    }
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(6, errors = validateFields(definition.fields));
    }
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(5, fieldNames = (0, import_function14.pipe)(definition.fields, A.map((f2) => f2.name)));
    }
  };
  $:
    $$invalidate(4, activeFieldIndex = 0);
  return [
    definition,
    onChange,
    onCancel,
    currentTab,
    activeFieldIndex,
    fieldNames,
    errors,
    isValid,
    duplicateField,
    moveField,
    handleSubmit,
    saveTemplate,
    handlePreview,
    onSubmit,
    onPreview,
    tabs_activeTab_binding,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    click_handler,
    click_handler_1,
    input0_input_handler_1,
    input1_input_handler_1,
    toggle_checked_binding,
    input2_input_handler_1,
    select_change_handler,
    inputbuilderselect_source_binding,
    inputbuilderselect_options_binding,
    inputbuilderselect_folder_binding,
    inputbuilderselect_source_binding_1,
    inputbuilderselect_options_binding_1,
    inputbuilderselect_folder_binding_1,
    inputbuilderselect_query_binding,
    input0_input_handler_2,
    input1_input_handler_2,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
var FormBuilder = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        definition: 0,
        onChange: 1,
        onSubmit: 13,
        onCancel: 2,
        onPreview: 14
      },
      add_css7,
      [-1, -1]
    );
  }
};
var FormBuilder_default = FormBuilder;

// src/store/store.ts
var settings = writable({ ...getDefaultSettings() });
var formsStore = derived(settings, ($settings) => pipe2(
  $settings.formDefinitions,
  A.filter((form) => !(form instanceof MigrationError))
));
var { subscribe: subscribe2, update: update2, set } = settings;
var invalidFormsStore = derived(settings, ($settings) => {
  return pipe2(
    $settings.formDefinitions,
    A.filter((form) => form instanceof MigrationError)
  );
});
var settingsStore = {
  subscribe: subscribe2,
  set,
  updateForm(name, form) {
    update2((s) => {
      const forms = s.formDefinitions.map((f2) => {
        if (f2.name === name)
          return form;
        return f2;
      });
      return { ...s, formDefinitions: forms };
    });
  },
  addNewForm(form) {
    update2((s) => {
      const forms = [...s.formDefinitions, form];
      return { ...s, formDefinitions: forms };
    });
  },
  removeForm(name) {
    update2((s) => {
      const forms = s.formDefinitions.filter((f2) => f2.name !== name);
      return { ...s, formDefinitions: forms };
    });
  },
  duplicateForm(formName) {
    update2((s) => {
      return { ...s, formDefinitions: duplicateForm(formName, s.formDefinitions) };
    });
  }
};

// src/views/EditFormView.ts
var EDIT_FORM_VIEW = "modal-form-edit-form-view";
function parseState(maybeState) {
  if (maybeState === null) {
    return false;
  }
  if (typeof maybeState !== "object") {
    return false;
  }
  if ("title" in maybeState && "name" in maybeState && "fields" in maybeState) {
    return true;
  }
  return false;
}
var EditFormView = class extends import_obsidian14.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.formState = { title: "", name: "", version: "1", fields: [] };
    this.icon = "note-glyph";
  }
  getViewType() {
    return EDIT_FORM_VIEW;
  }
  getDisplayText() {
    return "Edit form";
  }
  async onOpen() {
    this.containerEl.empty();
    this.formEditor = new FormBuilder_default({
      target: this.containerEl,
      props: {
        definition: this.formState,
        onChange: () => {
          console.log("Save form state", this.formState);
          this.app.workspace.requestSaveLayout();
        },
        onSubmit: (formDefinition) => {
          console.log("Submitting form", { formDefinition });
          if (this.originalFormName && this.originalFormName !== "") {
            settingsStore.updateForm(this.originalFormName, formDefinition);
          } else {
            settingsStore.addNewForm(formDefinition);
          }
          this.plugin.closeEditForm();
        },
        onCancel: () => {
          this.plugin.closeEditForm();
        },
        onPreview: async (formDefinition) => {
          const result = await this.plugin.api.openForm(formDefinition);
          const result_str = JSON.stringify(result, null, 2);
          log_notice("Form result", result_str);
          console.log(result_str);
        }
      }
    });
  }
  async onClose() {
    console.log("onClose of edit form called");
    this.formEditor.$destroy();
  }
  async setState(state, result) {
    console.log("setState of edit form called", state);
    if (parseState(state)) {
      this.formState = state;
      this.originalFormName = state.name;
      this.formEditor.$set({ definition: this.formState });
    }
    return super.setState(state, result);
  }
  getState() {
    return this.formState;
  }
};

// src/views/components/KeyValue.svelte
function add_css8(target) {
  append_styles(target, "svelte-1i8bb6o", "div.svelte-1i8bb6o{display:flex;flex-direction:row;align-items:flex-start;gap:var(--mf-spacing)}.key.svelte-1i8bb6o{color:var(--text-faint)}");
}
function create_fragment11(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(":");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(span, "class", "key svelte-1i8bb6o");
      attr(div, "class", "svelte-1i8bb6o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, span);
      append5(span, t0);
      append5(span, t1);
      append5(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*key*/
      1)
        set_data(
          t0,
          /*key*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [key, $$scope, slots];
}
var KeyValue = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance11, create_fragment11, safe_not_equal, { key: 0 }, add_css8);
  }
};
var KeyValue_default = KeyValue;

// src/views/components/Button.svelte
var import_obsidian15 = require("obsidian");
function create_fragment12(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      ctx[6](span);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      ctx[6](null);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { tooltip = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { text: text3 = void 0 } = $$props;
  let { variant = "regular" } = $$props;
  let { onClick } = $$props;
  const variants = {
    regular: "modal-form-regular",
    danger: "modal-form-danger",
    primary: "modal-form-primary"
  };
  let root;
  onMount(() => {
    const btn = new import_obsidian15.ButtonComponent(root);
    if (icon)
      btn.setIcon(icon);
    if (tooltip)
      btn.setTooltip(tooltip);
    if (text3)
      btn.setButtonText(text3);
    btn.onClick(onClick);
    btn.setClass(variants[variant]);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(0, root);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tooltip" in $$props2)
      $$invalidate(1, tooltip = $$props2.tooltip);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("text" in $$props2)
      $$invalidate(3, text3 = $$props2.text);
    if ("variant" in $$props2)
      $$invalidate(4, variant = $$props2.variant);
    if ("onClick" in $$props2)
      $$invalidate(5, onClick = $$props2.onClick);
  };
  return [root, tooltip, icon, text3, variant, onClick, span_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance12, create_fragment12, safe_not_equal, {
      tooltip: 1,
      icon: 2,
      text: 3,
      variant: 4,
      onClick: 5
    });
  }
};
var Button_default = Button;

// src/views/ManageForms.svelte
function add_css9(target) {
  append_styles(target, "svelte-432s91", ".form-row.svelte-432s91{display:flex;flex-direction:column;gap:8px}.form-row-buttons.svelte-432s91{display:flex;gap:8px}.form-name.svelte-432s91{margin-bottom:0}.header.svelte-432s91{display:flex;flex-direction:column;justify-content:space-between;align-items:flex-start}h5.svelte-432s91{margin-bottom:0}.flex-row.svelte-432s91{display:flex;flex-direction:row;gap:8px}pre.svelte-432s91{white-space:pre-wrap}.invalid-field-json.svelte-432s91{background-color:var(--background-secondary);margin:0}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i][0];
  child_ctx[32] = list[i][1];
  return child_ctx;
}
function create_if_block_33(ctx) {
  let h5;
  let t0;
  let t1_value = (
    /*$invalidForms*/
    ctx[3].length + ""
  );
  let t1;
  let t2;
  let t3;
  let p2;
  return {
    c() {
      h5 = element("h5");
      t0 = text("There are ");
      t1 = text(t1_value);
      t2 = text(" invalid forms.");
      t3 = space();
      p2 = element("p");
      p2.textContent = "Please take a look at the invalid forms section for details and\n            potential fixes.";
      attr(h5, "class", "modal-form-danger svelte-432s91");
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      append5(h5, t0);
      append5(h5, t1);
      append5(h5, t2);
      insert(target, t3, anchor);
      insert(target, p2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t1_value !== (t1_value = /*$invalidForms*/
      ctx2[3].length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
        detach(t3);
        detach(p2);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*key*/
        ctx[31]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        keyvalue_changes.key = /*key*/
        ctx2[31];
      if (dirty[0] & /*$forms*/
      16 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  let span;
  let t_value = (Array.isArray(
    /*value*/
    ctx[32]
  ) ? (
    /*value*/
    ctx[32].length
  ) : typeof /*value*/
  ctx[32] === "object" ? !!/*value*/
  ctx[32] : (
    /*value*/
    ctx[32]
  )) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16 && t_value !== (t_value = (Array.isArray(
        /*value*/
        ctx2[32]
      ) ? (
        /*value*/
        ctx2[32].length
      ) : typeof /*value*/
      ctx2[32] === "object" ? !!/*value*/
      ctx2[32] : (
        /*value*/
        ctx2[32]
      )) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*key*/
    ctx[31] !== "name" && create_if_block_23(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*key*/
        ctx2[31] !== "name"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$forms*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let span;
  let t0_value = (
    /*field*/
    ctx[28].name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16 && t0_value !== (t0_value = /*field*/
      ctx2[28].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
      }
    }
  };
}
function create_default_slot_22(ctx) {
  let span;
  let each_value_4 = ensure_array_like(
    /*form*/
    ctx[17].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(span, "display", "flex");
      set_style(span, "flex-direction", "column");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(span, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      16) {
        each_value_4 = ensure_array_like(
          /*form*/
          ctx2[17].fields
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_4.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let div2;
  let h4;
  let t0_value = (
    /*form*/
    ctx[17].name + ""
  );
  let t0;
  let t1;
  let div0;
  let t2;
  let keyvalue;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let t5;
  let button2;
  let t7;
  let button3;
  let current;
  let mounted;
  let dispose;
  let each_value_5 = ensure_array_like(Object.entries(
    /*form*/
    ctx[17]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  keyvalue = new KeyValue_default({
    props: {
      key: "Field names",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  function func() {
    return (
      /*func*/
      ctx[13](
        /*form*/
        ctx[17]
      )
    );
  }
  button0 = new Button_default({
    props: {
      onClick: func,
      tooltip: `Delete ${/*form*/
      ctx[17].name}`,
      icon: "trash",
      variant: "danger"
    }
  });
  function func_1() {
    return (
      /*func_1*/
      ctx[14](
        /*form*/
        ctx[17]
      )
    );
  }
  button1 = new Button_default({
    props: {
      onClick: func_1,
      text: "Edit",
      variant: "primary",
      icon: "pencil"
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*form*/
        ctx[17]
      )
    );
  }
  function func_2() {
    return (
      /*func_2*/
      ctx[16](
        /*form*/
        ctx[17]
      )
    );
  }
  button3 = new Button_default({
    props: {
      tooltip: `Copy ${/*form*/
      ctx[17].name} to clipboard`,
      icon: "clipboard-copy",
      onClick: func_2
    }
  });
  return {
    c() {
      div2 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(keyvalue.$$.fragment);
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<span>Duplicate</span>`;
      t7 = space();
      create_component(button3.$$.fragment);
      attr(h4, "class", "form-name svelte-432s91");
      attr(div1, "class", "form-row-buttons svelte-432s91");
      attr(div2, "class", "form-row svelte-432s91");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append5(div2, h4);
      append5(h4, t0);
      append5(div2, t1);
      append5(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append5(div0, t2);
      mount_component(keyvalue, div0, null);
      append5(div2, t3);
      append5(div2, div1);
      mount_component(button0, div1, null);
      append5(div1, t4);
      mount_component(button1, div1, null);
      append5(div1, t5);
      append5(div1, button2);
      append5(div1, t7);
      mount_component(button3, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(button2, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*$forms*/
      16) && t0_value !== (t0_value = /*form*/
      ctx[17].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$forms*/
      16) {
        each_value_5 = ensure_array_like(Object.entries(
          /*form*/
          ctx[17]
        ));
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, t2);
          }
        }
        group_outros();
        for (i = each_value_5.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      16 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx };
      }
      keyvalue.$set(keyvalue_changes);
      const button0_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button0_changes.onClick = func;
      if (dirty[0] & /*$forms*/
      16)
        button0_changes.tooltip = `Delete ${/*form*/
        ctx[17].name}`;
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button1_changes.onClick = func_1;
      button1.$set(button1_changes);
      const button3_changes = {};
      if (dirty[0] & /*$forms*/
      16)
        button3_changes.tooltip = `Copy ${/*form*/
        ctx[17].name} to clipboard`;
      if (dirty[0] & /*$forms*/
      16)
        button3_changes.onClick = func_2;
      button3.$set(button3_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_5.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(keyvalue.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(keyvalue.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(keyvalue);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block4(ctx) {
  let h3;
  let t1;
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$invalidForms*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Invalid forms";
      t1 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h3, "class", "form-name modal-form-danger svelte-432s91");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value = ensure_array_like(
          /*$invalidForms*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_else_block4(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: "field",
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      8 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let pre;
  let code;
  let t0;
  let t1_value = JSON.stringify(
    /*error*/
    ctx[20].left.field,
    null,
    1
  ) + "";
  let t1;
  let t2;
  let t3;
  let keyvalue;
  let t4;
  let hr;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*error*/
        ctx[20].left.path
      ),
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      pre = element("pre");
      code = element("code");
      t0 = text("\n                                    ");
      t1 = text(t1_value);
      t2 = text("\n                                ");
      t3 = space();
      create_component(keyvalue.$$.fragment);
      t4 = space();
      hr = element("hr");
      attr(pre, "class", "invalid-field-json svelte-432s91");
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append5(pre, code);
      append5(code, t0);
      append5(code, t1);
      append5(code, t2);
      insert(target, t3, anchor);
      mount_component(keyvalue, target, anchor);
      insert(target, t4, anchor);
      insert(target, hr, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      8) && t1_value !== (t1_value = JSON.stringify(
        /*error*/
        ctx2[20].left.field,
        null,
        1
      ) + ""))
        set_data(t1, t1_value);
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      8)
        keyvalue_changes.key = /*error*/
        ctx2[20].left.path;
      if (dirty[0] & /*$invalidForms*/
      8 | dirty[1] & /*$$scope*/
      16) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(pre);
        detach(t3);
        detach(t4);
        detach(hr);
      }
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_default_slot_13(ctx) {
  let span;
  let t0_value = (
    /*error*/
    ctx[20].right.name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" \u2705");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t0);
      append5(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t0_value !== (t0_value = /*error*/
      ctx2[20].right.name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_22(ctx) {
  let span;
  let t_value = (
    /*fieldError*/
    ctx[23] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8 && t_value !== (t_value = /*fieldError*/
      ctx2[23] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot5(ctx) {
  let each_1_anchor;
  let each_value_2 = ensure_array_like(
    /*error*/
    ctx[20].left.getFieldErrors()
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty2();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value_2 = ensure_array_like(
          /*error*/
          ctx2[20].left.getFieldErrors()
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_22(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_13(ctx) {
  let div;
  let show_if;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_13, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*$invalidForms*/
    8)
      show_if = null;
    if (show_if == null)
      show_if = !!E.isLeft(
        /*error*/
        ctx2[20]
      );
    if (show_if)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "flex-row svelte-432s91");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_each_block6(ctx) {
  let div;
  let h4;
  let t0_value = (
    /*form*/
    ctx[17].name + ""
  );
  let t0;
  let t1;
  let t2;
  let current;
  let each_value_1 = ensure_array_like(
    /*form*/
    ctx[17].fieldErrors
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      attr(h4, "class", "form-name svelte-432s91");
      attr(div, "class", "form-row svelte-432s91");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, h4);
      append5(h4, t0);
      append5(div, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append5(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      8) && t0_value !== (t0_value = /*form*/
      ctx2[17].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$invalidForms*/
      8) {
        each_value_1 = ensure_array_like(
          /*form*/
          ctx2[17].fieldErrors
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment13(ctx) {
  let div0;
  let h1;
  let t1;
  let button;
  let t2;
  let t3;
  let div1;
  let t4;
  let current;
  button = new Button_default({
    props: {
      onClick: (
        /*createNewForm*/
        ctx[0]
      ),
      text: "Create new form",
      variant: "primary"
    }
  });
  let if_block0 = (
    /*$invalidForms*/
    ctx[3].length && create_if_block_33(ctx)
  );
  let each_value_3 = ensure_array_like(
    /*$forms*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = (
    /*$invalidForms*/
    ctx[3].length && create_if_block4(ctx)
  );
  return {
    c() {
      div0 = element("div");
      h1 = element("h1");
      h1.textContent = "Manage forms";
      t1 = space();
      create_component(button.$$.fragment);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "header svelte-432s91");
      attr(div1, "id", "form-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append5(div0, h1);
      append5(div0, t1);
      mount_component(button, div0, null);
      append5(div0, t2);
      if (if_block0)
        if_block0.m(div0, null);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append5(div1, t4);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*createNewForm*/
      1)
        button_changes.onClick = /*createNewForm*/
        ctx2[0];
      button.$set(button_changes);
      if (
        /*$invalidForms*/
        ctx2[3].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*$forms, handleCopyForm, handleDuplicateForm, handleEditForm, handleDeleteForm*/
      496) {
        each_value_3 = ensure_array_like(
          /*$forms*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t4);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*$invalidForms*/
        ctx2[3].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$invalidForms*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t3);
        detach(div1);
      }
      destroy_component(button);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let $invalidForms, $$unsubscribe_invalidForms = noop, $$subscribe_invalidForms = () => ($$unsubscribe_invalidForms(), $$unsubscribe_invalidForms = subscribe(invalidForms, ($$value) => $$invalidate(3, $invalidForms = $$value)), invalidForms);
  let $forms, $$unsubscribe_forms = noop, $$subscribe_forms = () => ($$unsubscribe_forms(), $$unsubscribe_forms = subscribe(forms, ($$value) => $$invalidate(4, $forms = $$value)), forms);
  $$self.$$.on_destroy.push(() => $$unsubscribe_invalidForms());
  $$self.$$.on_destroy.push(() => $$unsubscribe_forms());
  let { createNewForm } = $$props;
  let { deleteForm } = $$props;
  let { duplicateForm: duplicateForm2 } = $$props;
  let { editForm } = $$props;
  let { copyFormToClipboard } = $$props;
  let { forms } = $$props;
  $$subscribe_forms();
  let { invalidForms } = $$props;
  $$subscribe_invalidForms();
  function handleDeleteForm(formName) {
    const confirmed = confirm(`Are you sure you want to delete ${formName}?`);
    if (confirmed) {
      console.log(`Deleting ${formName}`);
      deleteForm(formName);
    }
  }
  function handleEditForm(formName) {
    console.log(`Editing ${formName}`);
    editForm(formName);
  }
  function handleDuplicateForm(form) {
    console.log(`Duplicating ${form.name}`);
    duplicateForm2(form.name);
  }
  function handleCopyForm(form) {
    console.log(`Copying ${form.name}`);
    copyFormToClipboard(form);
  }
  const func = (form) => handleDeleteForm(form.name);
  const func_1 = (form) => handleEditForm(form.name);
  const click_handler = (form) => handleDuplicateForm(form);
  const func_2 = (form) => handleCopyForm(form);
  $$self.$$set = ($$props2) => {
    if ("createNewForm" in $$props2)
      $$invalidate(0, createNewForm = $$props2.createNewForm);
    if ("deleteForm" in $$props2)
      $$invalidate(9, deleteForm = $$props2.deleteForm);
    if ("duplicateForm" in $$props2)
      $$invalidate(10, duplicateForm2 = $$props2.duplicateForm);
    if ("editForm" in $$props2)
      $$invalidate(11, editForm = $$props2.editForm);
    if ("copyFormToClipboard" in $$props2)
      $$invalidate(12, copyFormToClipboard = $$props2.copyFormToClipboard);
    if ("forms" in $$props2)
      $$subscribe_forms($$invalidate(1, forms = $$props2.forms));
    if ("invalidForms" in $$props2)
      $$subscribe_invalidForms($$invalidate(2, invalidForms = $$props2.invalidForms));
  };
  return [
    createNewForm,
    forms,
    invalidForms,
    $invalidForms,
    $forms,
    handleDeleteForm,
    handleEditForm,
    handleDuplicateForm,
    handleCopyForm,
    deleteForm,
    duplicateForm2,
    editForm,
    copyFormToClipboard,
    func,
    func_1,
    click_handler,
    func_2
  ];
}
var ManageForms = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        createNewForm: 0,
        deleteForm: 9,
        duplicateForm: 10,
        editForm: 11,
        copyFormToClipboard: 12,
        forms: 1,
        invalidForms: 2
      },
      add_css9,
      [-1, -1]
    );
  }
};
var ManageForms_default = ManageForms;

// src/views/ManageFormsView.ts
var import_obsidian16 = require("obsidian");
var MANAGE_FORMS_VIEW = "modal-form-manage-forms-view";
var ManageFormsView = class extends import_obsidian16.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.icon = "documents";
  }
  getViewType() {
    return MANAGE_FORMS_VIEW;
  }
  getDisplayText() {
    return "Manage forms";
  }
  async onOpen() {
    const container = this.containerEl.children[1] || this.containerEl.createDiv();
    container.empty();
    this.component = new ManageForms_default({
      target: container,
      props: {
        forms: formsStore,
        invalidForms: invalidFormsStore,
        createNewForm: () => {
          this.plugin.createNewForm();
        },
        editForm: (formName) => {
          this.plugin.editForm(formName);
        },
        deleteForm: (formName) => {
          settingsStore.removeForm(formName);
        },
        duplicateForm: (formName) => {
          settingsStore.duplicateForm(formName);
        },
        copyFormToClipboard: async (form) => {
          await navigator.clipboard.writeText(JSON.stringify(form, null, 2));
          new import_obsidian16.Notice("Form has been copied to the clipboard");
        }
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/main.ts
var import_function15 = __toESM(require_function());

// src/suggesters/NewNoteModal.ts
var import_obsidian18 = require("obsidian");

// src/suggesters/suggestGeneric.ts
var import_obsidian17 = require("obsidian");
var GenericSuggest = class extends import_obsidian17.AbstractInputSuggest {
  constructor(app2, inputEl, content, strategy) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.strategy = strategy;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    return this.strategy.getSuggestions(lowerCaseInputStr, [...this.content]);
  }
  renderSuggestion(content, el) {
    return this.strategy.renderSuggestion(content, el);
  }
  selectSuggestion(value) {
    this.inputEl.value = this.strategy.selectSuggestion(value);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/NewNoteModal.ts
var formSuggester = (app2, input, forms, onChange) => new GenericSuggest(
  app2,
  input,
  new Set(forms),
  {
    getSuggestions: (inputStr, forms2) => {
      return forms2.filter((form) => form.name.toLowerCase().contains(inputStr));
    },
    renderSuggestion: (form, el) => {
      el.setText(form.name);
    },
    selectSuggestion: (form) => {
      onChange(form);
      return form.name;
    }
  }
);
var NewNoteModal = class extends import_obsidian18.Modal {
  constructor(app2, forms, onSelected) {
    super(app2);
    this.forms = forms;
    this.onSelected = onSelected;
  }
  onOpen() {
    let destinationFolder = "";
    let form;
    let noteName = "";
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "New Note from form" });
    new import_obsidian18.Setting(contentEl).addSearch((element2) => {
      formSuggester(this.app, element2.inputEl, this.forms, (value) => {
        form = value;
      });
    }).setDesc("Pick a form");
    new import_obsidian18.Setting(contentEl).addSearch((element2) => {
      new FolderSuggest(element2.inputEl, this.app);
      element2.onChange((value) => {
        destinationFolder = value;
      });
    }).setName("Destination folder");
    new import_obsidian18.Setting(contentEl).addText((element2) => {
      element2.onChange((value) => {
        noteName = value;
      });
    }).setName("Note name");
    new import_obsidian18.Setting(contentEl).addButton((element2) => {
      element2.setButtonText("Create new note");
      element2.onClick(() => {
        if (!form || !destinationFolder.trim() || !noteName.trim()) {
          log_notice("Missing fields", "Please fill all the fields");
          return;
        }
        this.close();
        this.onSelected({
          form,
          folder: destinationFolder.trim(),
          noteName: noteName.trim()
        });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
function notifyParsingErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "Some forms could not be parsed",
    `We found some invalid data while parsing the form settings, please take a look at the following errors: 
            ${errors.join("\n")}`
  );
}
function notifyMigrationErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "Some forms could not be migrated",
    `We tried to perform an automatic migration, but we failed. Go to the forms manager and fix the following forms:
            ${errors.map((e) => e.name).join("\n")}`
  );
}
var ModalFormPlugin = class extends import_obsidian19.Plugin {
  constructor() {
    super(...arguments);
    this.unsubscribeSettingsStore = () => {
    };
  }
  manageForms() {
    return this.activateView(MANAGE_FORMS_VIEW);
  }
  createNewForm() {
    return this.activateView(EDIT_FORM_VIEW);
  }
  /**
   * Opens the form in the editor.
   * @returns
   */
  async editForm(formName) {
    const savedSettings = await this.getSettings();
    const formDefinition = savedSettings.formDefinitions.find(
      (form) => form.name === formName
    );
    if (!formDefinition) {
      throw new ModalFormError(`Form ${formName} not found`);
    }
    if (formDefinition instanceof MigrationError) {
      notifyMigrationErrors([formDefinition]);
      return;
    }
    await this.activateView(EDIT_FORM_VIEW, formDefinition);
  }
  closeEditForm() {
    this.app.workspace.detachLeavesOfType(EDIT_FORM_VIEW);
  }
  onunload() {
    this.unsubscribeSettingsStore();
  }
  async activateView(viewType, state) {
    var _a, _b, _c, _d;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(viewType)[0];
    if (leaf) {
      console.info("found leaf, no reason to create a new one");
    } else if (import_obsidian19.Platform.isMobile || ((_a = this.settings) == null ? void 0 : _a.editorPosition) === "mainView") {
      leaf = this.app.workspace.getLeaf("tab");
    } else if (((_b = this.settings) == null ? void 0 : _b.editorPosition) === "right") {
      leaf = this.app.workspace.getRightLeaf(false);
    } else if (((_c = this.settings) == null ? void 0 : _c.editorPosition) === "left") {
      leaf = this.app.workspace.getLeftLeaf(false);
    } else if (((_d = this.settings) == null ? void 0 : _d.editorPosition) === "modal") {
      leaf = this.app.workspace.getLeaf(false);
    } else {
      leaf = this.app.workspace.getRightLeaf(false);
    }
    await leaf.setViewState({
      type: viewType,
      active: true,
      state
    });
    this.app.workspace.revealLeaf(leaf);
    return leaf;
  }
  // TODO: extract the migration logic to a separate function and test it
  // TODO: collect actual migration events to decide if we need to migrate or not rather than this naive approach
  async getSettings() {
    const data = await this.loadData();
    const [migrationIsNeeded, settings2] = (0, import_function15.pipe)(
      parseSettings(data),
      map((settings3) => {
        const migrationIsNeeded2 = settings3.formDefinitions.some(formNeedsMigration);
        const { right: formDefinitions, left: errors } = partitionMap(
          migrateToLatest
        )(settings3.formDefinitions);
        notifyParsingErrors(errors);
        const validSettings = {
          ...settings3,
          formDefinitions
        };
        return [migrationIsNeeded2, validSettings];
      }),
      getOrElse(() => [false, getDefaultSettings()])
    );
    if (migrationIsNeeded) {
      await this.saveSettings(settings2);
      console.info("Settings were migrated to the latest version");
    }
    return settings2;
  }
  async saveSettings(newSettings) {
    await this.saveData(newSettings || this.settings);
  }
  async setEditorPosition(position) {
    this.settings.editorPosition = position;
    await this.saveSettings();
  }
  async onload() {
    const settings2 = await this.getSettings();
    if (settings2.formDefinitions.length === 0) {
      settings2.formDefinitions.push(exampleModalDefinition);
    }
    settingsStore.set(settings2);
    this.unsubscribeSettingsStore = settingsStore.subscribe((s) => {
      console.log("settings changed", s);
      this.settings = s;
      this.saveSettings(s);
    });
    this.api = new API(this.app, this);
    this.registerView(
      EDIT_FORM_VIEW,
      (leaf) => new EditFormView(leaf, this)
    );
    this.registerView(
      MANAGE_FORMS_VIEW,
      (leaf) => new ManageFormsView(leaf, this)
    );
    this.addRibbonIcon("documents", "Edit forms", (evt) => {
      this.manageForms();
    });
    this.addCommand({
      id: "new-form",
      name: "New form",
      callback: () => {
        this.createNewForm();
      }
    });
    this.addCommand({
      id: "manage-forms",
      name: "Manage forms",
      callback: () => {
        this.manageForms();
      }
    });
    this.addCommand({
      id: "create-note-from-form",
      name: "Create new note from a form",
      callback: () => {
        this.createNoteFromForm();
      }
    });
    this.addSettingTab(new ModalFormSettingTab(this.app, this));
  }
  /**
   * Finds a unique name for a note, given a name.
   * It just adds a number at the end of the name if the name is already taken.
   * @param name the name of the note, without the extension
   * @returns a unique name for the note, full path including the extension
   */
  getUniqueNoteName(name, destinationFolder) {
    const defaultNotesFolder = this.app.fileManager.getNewFileParent(
      "",
      "note.md"
    );
    function makePath(name2, folder, suffix) {
      return `${folder || defaultNotesFolder.path}/${name2}${suffix ? "-" + suffix : ""}.md`;
    }
    let destinationPath = makePath(name, destinationFolder);
    let i = 1;
    while (file_exists(destinationPath, this.app)) {
      destinationPath = makePath(name, destinationFolder, i);
      i++;
    }
    return destinationPath;
  }
  /**
   * Checks if there are forms with templates, and presents a prompt
   * to select a form, then opens the forms, and creates a new note
   * with the template and the form values
   */
  createNoteFromForm() {
    const formsWithTemplates = (0, import_function15.pipe)(
      this.settings.formDefinitions,
      filterMap((form) => {
        if (form instanceof MigrationError) {
          return O.none;
        }
        if (form.template !== void 0) {
          return O.some(form);
        }
        return O.none;
      })
    );
    const onFormSelected = async (form, noteName, destinationFolder) => {
      const formData = await this.api.openForm(form);
      const newNoteFullPath = this.getUniqueNoteName(
        noteName,
        destinationFolder
      );
      const noteContent = executeTemplate(
        form.template.parsedTemplate,
        formData.getData()
      );
      console.log("new note content", noteContent);
      this.app.vault.create(newNoteFullPath, noteContent);
    };
    const picker = new NewNoteModal(
      this.app,
      formsWithTemplates,
      ({ form, folder, noteName }) => {
        onFormSelected(form, noteName, folder);
      }
    );
    picker.open();
  }
};
