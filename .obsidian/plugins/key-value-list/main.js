/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => KeyValueListPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/key-value-list.ts
var import_state = require("@codemirror/state");
var import_obsidian2 = require("obsidian");
var import_view2 = require("@codemirror/view");
var import_obsidian3 = require("obsidian");

// src/widgets.ts
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var KeyValueLineWidget = class extends import_view.WidgetType {
  constructor(plugin, listId, listIndex, textLine, maxKeyWidth, listItemWidth, path) {
    super();
    this.plugin = plugin;
    this.listId = listId;
    this.listIndex = listIndex;
    this.textLine = textLine;
    this.maxKeyWidth = maxKeyWidth;
    this.listItemWidth = listItemWidth;
    this.path = path;
  }
  eq(other) {
    return this.listId === other.listId && this.listIndex === other.listIndex && this.textLine === other.textLine && this.maxKeyWidth === other.maxKeyWidth && this.listItemWidth === other.listItemWidth && this.path === other.path;
  }
  toDOM() {
    const settings = this.plugin.settings;
    const bullet = "-";
    const displayBulletChar = settings.displayBulletChar || "-";
    const delimiter = settings.delimiter || ":";
    const isEven = this.listIndex % 2 == 0;
    const split = this.textLine.indexOf(delimiter);
    let key = `${settings.displayBullet ? `\\${displayBulletChar} ` : ""}${this.textLine.substring(
      bullet.length + 1,
      split + (settings.displayDelimiter ? delimiter.length : 0)
    ).trim()}`;
    if (!settings.displayBullet && key.charAt(0) === "[") {
      key = `- ${key}`;
    } else if (settings.displayBullet && key.startsWith("\\- [")) {
      key = key.substring(1);
    }
    let value = this.textLine.substring(split + delimiter.length).trim();
    const row = document.createElement("span");
    row.id = `kvl-${this.listId}-${this.listIndex}`;
    row.className = `kvl-row kvl-row-${this.listId} ${isEven ? "kvl-row-even" : "kvl-row-odd"} ${settings.stripedBackgroundType === "default" ? "striped" : ""}`;
    if (isEven && settings.stripedBackgroundType === "custom") {
      row.style.backgroundColor = settings.stripedBackgroundColor;
    }
    row.style.padding = `${settings.verticalPadding}px ${settings.horizontalPadding}px`;
    if (this.listItemWidth.row) {
      row.style.minWidth = `${this.listItemWidth.row}px`;
    }
    const rowInner = document.createElement("span");
    rowInner.className = `kvl-row-inner kvl-row-inner-${this.listId}`;
    const keySpan = document.createElement(
      settings.boldKey ? "strong" : "span"
    );
    keySpan.className = `kvl-key kvl-key-${this.listId}`;
    if (this.listItemWidth.key) {
      keySpan.style.minWidth = `${this.listItemWidth.key}px`;
    }
    const keySpanInner = document.createElement("span");
    if (this.maxKeyWidth > 0) {
      keySpanInner.style.maxWidth = `${this.maxKeyWidth}px`;
    }
    if (settings.isKeyColored) {
      keySpanInner.style.color = settings.keyColor;
    }
    keySpanInner.className = `kvl-key-inner kvl-key-inner-${this.listId}`;
    this.renderMarkdown(key, keySpanInner);
    const valueSpan = document.createElement("span");
    valueSpan.className = "kvl-value";
    if (settings.isValueColored) {
      valueSpan.style.color = settings.valueColor;
    }
    value = value.replace(/\[(\^\d+)\]/g, "\\$1");
    this.renderMarkdown(value, valueSpan);
    row.appendChild(rowInner);
    rowInner.appendChild(keySpan);
    keySpan.appendChild(keySpanInner);
    rowInner.appendChild(valueSpan);
    return row;
  }
  renderMarkdown(html, container) {
    import_obsidian.MarkdownRenderer.render(
      this.plugin.app,
      html,
      container,
      this.path,
      this.plugin
    );
  }
  ignoreEvent() {
    return false;
  }
};

// src/key-value-list.ts
var excludeFileFromCssClasses = (plugin) => {
  const noteFile = plugin.app.workspace.getActiveFile();
  if (noteFile) {
    const metadata = plugin.app.metadataCache.getFileCache(noteFile);
    if (metadata == null ? void 0 : metadata.frontmatter) {
      return (metadata.frontmatter.cssclasses || []).includes("nokeyvalue");
    }
  }
  return false;
};
var KeyValueList = class {
  constructor(plugin, parser) {
    this.plugin = plugin;
    this.parser = parser;
  }
  async load() {
    const plugin = this.plugin;
    const parser = this.parser;
    this.plugin.registerMarkdownPostProcessor((element, context) => {
      if (!this.plugin.settings.activeInReadMode || excludeFileFromCssClasses(plugin)) {
        return;
      }
      const listElements = element.findAll("ul");
      const displayBulletChar = plugin.settings.displayBulletChar || "-";
      for (const listElement of listElements) {
        const listItems = listElement.findAll("li");
        const isKeyValueList = listItems.every(
          (listItem) => parser.isKeyValueLiElem(listItem.innerText.trim())
        );
        if (isKeyValueList) {
          const table = document.createElement("table");
          table.classList.add("kvl-table");
          listElement.replaceWith(table);
          let rowIndex = 0;
          for (const listItem of listItems) {
            const tr = document.createElement("tr");
            if (++rowIndex % 2 == 0) {
              if (plugin.settings.stripedBackgroundType === "custom" && plugin.settings.stripedBackgroundColor) {
                tr.style.backgroundColor = plugin.settings.stripedBackgroundColor;
              }
              tr.classList.add("kvl-row-even");
            } else {
              tr.classList.add("kvl-row-odd");
            }
            table.appendChild(tr);
            const tdKey = document.createElement("td");
            tr.appendChild(tdKey);
            let keyText = parser.getKeyFromLiElem(listItem.innerHTML.trim());
            if (plugin.settings.displayDelimiter) {
              keyText += plugin.settings.delimiter;
            }
            if (plugin.settings.displayBullet) {
              keyText = `${displayBulletChar} ${keyText}`;
            }
            const keyElemType = plugin.settings.boldKey ? "strong" : "span";
            const keyElem = document.createElement(keyElemType);
            keyElem.innerHTML = keyText;
            if (plugin.settings.isKeyColored) {
              keyElem.style.color = plugin.settings.keyColor;
            }
            tdKey.style.padding = `${plugin.settings.verticalPadding + 2}px ${plugin.settings.horizontalPadding}px`;
            tdKey.appendChild(keyElem);
            const tdValue = document.createElement("td");
            tdValue.innerHTML = parser.getValueFromLiElem(
              listItem.innerHTML.trim()
            );
            tdValue.style.padding = `${plugin.settings.verticalPadding + 2}px ${plugin.settings.horizontalPadding}px`;
            if (plugin.settings.isValueColored) {
              tdValue.style.color = plugin.settings.valueColor;
            }
            tr.appendChild(tdValue);
          }
        }
      }
    });
    this.plugin.registerEditorExtension(
      import_view2.ViewPlugin.fromClass(
        class KVLPlugin {
          constructor(view) {
            this.setupEditor = () => {
              const field = this.view.state.field(import_obsidian3.editorInfoField);
              let editor;
              try {
                editor = field.editor;
              } catch (error) {
                editor = void 0;
              }
              if (!editor) {
                setTimeout(this.setupEditor, 0);
                return;
              }
              this.editor = editor;
              this.updateCounter = 10;
            };
            this.view = view;
            this.listWidths = [];
            this.lastTouchedListIndex = -1;
            this.updateCounter = 0;
            this.decorations = this.buildDecorations(view, []);
            this.setupEditor();
          }
          update(update) {
            if (!this.editor || !plugin.settings.activeInEditMode || excludeFileFromCssClasses(plugin)) {
              this.decorations = import_view2.Decoration.none;
              return;
            }
            const lists = this.view.viewportLineBlocks.length > 0 && this.view.visibleRanges.length > 0 ? parser.collectLists(
              this.editor,
              this.editor.offsetToPos(this.view.viewport.from).line,
              this.editor.offsetToPos(this.view.viewport.to).line
            ).filter((list) => list.isKeyValueList) : [];
            if (lists.length != this.listWidths.length) {
              this.listWidths = lists.map(() => ({
                key: 0,
                row: 0,
                keyNeedsUpdate: true,
                rowNeedsUpdate: true
              }));
            }
            const touchedListIndex = lists.findIndex(
              (list) => list.hasCursorInside
            );
            const isAnyListTouched = touchedListIndex >= 0;
            if (!isAnyListTouched && this.lastTouchedListIndex !== -1) {
              if (this.listWidths[this.lastTouchedListIndex]) {
                this.listWidths[this.lastTouchedListIndex].keyNeedsUpdate = true;
                this.listWidths[this.lastTouchedListIndex].rowNeedsUpdate = false;
              }
              this.lastTouchedListIndex = -1;
              this.updateCounter = 3;
            } else if (isAnyListTouched) {
              this.lastTouchedListIndex = touchedListIndex;
            }
            if (update.docChanged || update.viewportChanged || isAnyListTouched || this.updateCounter || parser.needsUpdate) {
              if (this.updateCounter > 0) {
                this.updateCounter--;
              }
              if (parser.needsUpdate) {
                parser.needsUpdate = false;
              }
              this.decorations = this.buildDecorations(update.view, lists);
            }
          }
          getListWidths(lists) {
            lists.forEach((_list, index) => {
              this.listWidths[index] = {
                key: Math.max(
                  this.listWidths[index].keyNeedsUpdate ? 0 : this.listWidths[index].key,
                  ...Array.from(
                    document.getElementsByClassName(`kvl-key-inner-${index}`)
                  ).map((elem) => elem.clientWidth + 20)
                ),
                row: Math.max(
                  this.listWidths[index].rowNeedsUpdate ? 0 : this.listWidths[index].row,
                  ...Array.from(
                    document.getElementsByClassName(`kvl-row-inner-${index}`)
                  ).map(
                    (elem) => elem.children[0].clientWidth + elem.children[1].clientWidth + plugin.settings.horizontalPadding * 2
                  )
                ),
                keyNeedsUpdate: false,
                rowNeedsUpdate: this.listWidths[index].keyNeedsUpdate
              };
            });
          }
          buildDecorations(view, lists) {
            const builder = new import_state.RangeSetBuilder();
            if (!this.editor || excludeFileFromCssClasses(plugin)) {
              return builder.finish();
            }
            const cursor = this.editor.getCursor();
            this.getListWidths(lists);
            const maxKeyWidth = plugin.settings.maxKeyWidth / 100 * view.dom.clientWidth;
            const markdownView = plugin.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
            lists.forEach((list, index) => {
              var _a;
              for (let lineNumber = list.start.line; lineNumber < list.end.line; lineNumber++) {
                if (lineNumber === cursor.line) {
                  continue;
                }
                const line = view.state.doc.line(lineNumber + 1);
                builder.add(
                  line.from,
                  line.to,
                  import_view2.Decoration.replace({
                    widget: new KeyValueLineWidget(
                      plugin,
                      index,
                      lineNumber,
                      line.text,
                      maxKeyWidth,
                      this.listWidths[index],
                      ((_a = markdownView == null ? void 0 : markdownView.file) == null ? void 0 : _a.path) || ""
                    )
                  })
                );
              }
            });
            return builder.finish();
          }
        },
        {
          decorations: (value) => plugin.settings.activeInEditMode && !excludeFileFromCssClasses(plugin) ? value.decorations : import_view2.Decoration.none
        }
      )
    );
  }
  async unload() {
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  activeInEditMode: true,
  activeInReadMode: true,
  displayBullet: false,
  displayBulletChar: "-",
  delimiter: ":",
  displayDelimiter: true,
  maxKeyWidth: 50,
  verticalPadding: 3,
  horizontalPadding: 12,
  boldKey: true,
  stripedBackgroundType: "default",
  stripedBackgroundColor: "",
  isKeyColored: false,
  keyColor: "",
  isValueColored: false,
  valueColor: ""
};
var SettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const foldablePadding = 42;
    new import_obsidian4.Setting(containerEl).setName("Active in edit mode").setDesc("If the plugin should be active in edit mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.activeInEditMode).onChange(async (value) => {
        this.plugin.settings.activeInEditMode = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Active in read mode").setDesc("If the plugin should be active in read mode").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.activeInReadMode).onChange(async (value) => {
        this.plugin.settings.activeInReadMode = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Display bullet").setDesc("If the bullet should be displayed or not").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.displayBullet).onChange(async (value) => {
        displayBulletChar.settingEl.toggleClass("disabled", !value);
        displayBulletChar.settingEl.style.height = value ? `${displayBulletChar.settingEl.innerHeight + foldablePadding}px` : "0px";
        this.plugin.settings.displayBullet = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const displayBulletChar = new import_obsidian4.Setting(containerEl).setName("Bullet character").setDesc(
      "The character(s) to be displayed for bullets. The trigger bullet will always be a dash (-) regardless of this setting."
    ).setClass("foldable-setting").setClass(this.plugin.settings.displayBullet ? "enabled" : "disabled").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.displayBulletChar).setValue(this.plugin.settings.displayBulletChar).onChange(async (value) => {
        this.plugin.settings.displayBulletChar = value;
        await this.plugin.saveSettings();
        this.plugin.refresh();
      })
    ).then((setting) => {
      setting.settingEl.style.height = this.plugin.settings.displayBullet ? `${setting.settingEl.clientHeight}px` : "0px";
    });
    new import_obsidian4.Setting(containerEl).setName("Display delimiter").setDesc("If the delimiter should be displayed in the key or not").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.displayDelimiter).onChange(async (value) => {
        displayDelimiterChar.settingEl.toggleClass("disabled", !value);
        displayDelimiterChar.settingEl.style.height = value ? `${displayDelimiterChar.settingEl.innerHeight + foldablePadding}px` : "0px";
        this.plugin.settings.displayDelimiter = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const displayDelimiterChar = new import_obsidian4.Setting(containerEl).setName("Delimiter").setDesc("The character(s) that separate the key from the value").setClass("foldable-setting").setClass(this.plugin.settings.displayDelimiter ? "enabled" : "disabled").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.delimiter).setValue(this.plugin.settings.delimiter).onChange(async (value) => {
        this.plugin.settings.delimiter = value;
        await this.plugin.saveSettings();
        this.plugin.refresh();
      })
    ).then((setting) => {
      setting.settingEl.style.height = this.plugin.settings.displayDelimiter ? `${setting.settingEl.clientHeight}px` : "0px";
    });
    new import_obsidian4.Setting(containerEl).setName("Max key width").setDesc(
      "Maximum width of the key in percent of the editor width. 0 = no limit"
    ).addSlider(
      (slider) => slider.setLimits(0, 99, 1).setValue(this.plugin.settings.maxKeyWidth).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxKeyWidth = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Vertical padding").setDesc("Vertical padding of the key-value list rows (in pixels)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder(DEFAULT_SETTINGS.verticalPadding.toString()).setValue((_a = this.plugin.settings.verticalPadding) == null ? void 0 : _a.toString()).onChange(async (value) => {
          let numericValue = parseInt(value);
          if (isNaN(numericValue)) {
            numericValue = 0;
          }
          this.plugin.settings.verticalPadding = numericValue;
          text.setValue(numericValue.toString());
          await this.plugin.saveSettings();
          this.plugin.refresh();
        });
      }
    );
    new import_obsidian4.Setting(containerEl).setName("Horizontal padding").setDesc("Horizontal padding of the key-value list rows (in pixels)").addText(
      (text) => {
        var _a;
        return text.setPlaceholder(DEFAULT_SETTINGS.horizontalPadding.toString()).setValue((_a = this.plugin.settings.horizontalPadding) == null ? void 0 : _a.toString()).onChange(async (value) => {
          let numericValue = parseInt(value);
          if (isNaN(numericValue)) {
            numericValue = 0;
          }
          this.plugin.settings.horizontalPadding = numericValue;
          text.setValue(numericValue.toString());
          await this.plugin.saveSettings();
          this.plugin.refresh();
        });
      }
    );
    new import_obsidian4.Setting(containerEl).setName("Bold keys").setDesc("It the keys should be rendered in a bold font").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.boldKey).onChange(async (value) => {
        this.plugin.settings.boldKey = value;
        await this.plugin.saveData(this.plugin.settings);
        this.plugin.refresh();
      })
    );
    const backgroundColorOptions = [
      { key: "none", label: "No background color" },
      { key: "default", label: "Default background color (based on theme)" },
      { key: "custom", label: "Custom background color" }
    ];
    new import_obsidian4.Setting(containerEl).setName("Striped background").setDesc("Choose if even rows should have another background color").addDropdown((dropdown) => {
      backgroundColorOptions.forEach((option) => {
        dropdown.addOption(option.key, option.label);
      });
      dropdown.setValue(this.plugin.settings.stripedBackgroundType);
      dropdown.onChange(async (value) => {
        this.plugin.settings.stripedBackgroundType = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      });
    });
    if (this.plugin.settings.stripedBackgroundType === "custom") {
      new import_obsidian4.Setting(containerEl).setName("Striped background color").setDesc("Choose the color of the striped background.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.stripedBackgroundColor).onChange(async (value) => {
          this.plugin.settings.stripedBackgroundColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Custom key color").setDesc("If a custom color should be used for the keys").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.isKeyColored).onChange(async (value) => {
        this.plugin.settings.isKeyColored = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      })
    );
    if (this.plugin.settings.isKeyColored) {
      new import_obsidian4.Setting(containerEl).setName("Key color").setDesc("Choose the color of the keys.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.keyColor).onChange(async (value) => {
          this.plugin.settings.keyColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Custom value color").setDesc("If a custom color should be used for the values").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.isValueColored).onChange(async (value) => {
        this.plugin.settings.isValueColored = value;
        await this.plugin.saveData(this.plugin.settings);
        this.display();
        this.plugin.refresh();
      })
    );
    if (this.plugin.settings.isValueColored) {
      new import_obsidian4.Setting(containerEl).setName("Value color").setDesc("Choose the color of the values.").addColorPicker(
        (color) => color.setValue(this.plugin.settings.valueColor).onChange(async (value) => {
          this.plugin.settings.valueColor = value;
          await this.plugin.saveData(this.plugin.settings);
          this.plugin.refresh();
        })
      );
    }
    new import_obsidian4.Setting(containerEl).setName("Reset settings").setDesc("Reset all settings to their default values").addButton(
      (button) => button.setButtonText("Reset settings").onClick(async () => {
        if (confirm("Are you sure you want to reset the settings?")) {
          this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
          await this.plugin.saveData(this.plugin.settings);
          this.display();
          this.plugin.refresh();
        }
      })
    );
  }
};

// src/list.ts
var List = class {
  constructor(start, end, isKeyValueList, hasCursorInside) {
    this.start = start;
    this.end = end;
    this.isKeyValueList = isKeyValueList;
    this.hasCursorInside = hasCursorInside;
  }
};

// src/utils.ts
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/list-parser.ts
var listItemReg = new RegExp(`^[ 	]*-(.*)`);
var ListParser = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.needsUpdate = false;
    this.update();
  }
  update() {
    const bullet = "-";
    const delimiter = escapeRegExp(
      this.plugin.settings.delimiter || DEFAULT_SETTINGS.delimiter
    );
    this.keyValueReg = new RegExp(`^[ 	]*${bullet}(.*)${delimiter} (.*)`);
    this.liElemReg = new RegExp(`^(.*)${delimiter} (.*)`);
    this.needsUpdate = true;
  }
  /**
   * Collects all lists within a given range.
   * @param  {Editor} editor    The editor to parse.
   * @param  {Number} startLine The line to start parsing from.
   * @param  {Number} endLine   The line to stop parsing at.
   * @return {List[]}           A list of all lists found.
   * @public
   */
  collectLists(editor, startLine = 0, endLine = editor.lastLine()) {
    const lists = [];
    const cursorLine = editor.getCursor().line;
    for (let currentLine = startLine; currentLine <= endLine; currentLine++) {
      const line = editor.getLine(currentLine);
      if (this.isLineList(line)) {
        let isKeyValueList = true;
        let hasCursorInside = false;
        let listEndLineLookup = currentLine;
        while (listEndLineLookup <= editor.lastLine()) {
          const line2 = editor.getLine(listEndLineLookup);
          if (!this.isLineList(line2)) {
            break;
          }
          if (cursorLine === listEndLineLookup) {
            hasCursorInside = true;
          }
          if (!this.isKeyValueListItem(line2) && cursorLine !== listEndLineLookup) {
            isKeyValueList = false;
          }
          if (listEndLineLookup >= endLine) {
            listEndLineLookup = endLine;
            break;
          }
          listEndLineLookup++;
        }
        lists.push(
          new List(
            { line: currentLine, ch: 0 },
            {
              line: listEndLineLookup,
              ch: editor.getLine(listEndLineLookup).length
            },
            isKeyValueList,
            hasCursorInside
          )
        );
        currentLine = listEndLineLookup;
      }
    }
    return lists;
  }
  isLineList(line) {
    return listItemReg.test(line);
  }
  isKeyValueLiElem(line) {
    return this.liElemReg.test(line);
  }
  getKeyFromLiElem(line) {
    var _a;
    return ((_a = line.match(this.liElemReg)) == null ? void 0 : _a[1]) || "";
  }
  getValueFromLiElem(line) {
    var _a;
    return ((_a = line.match(this.liElemReg)) == null ? void 0 : _a[2]) || "";
  }
  isKeyValueListItem(line) {
    return this.keyValueReg.test(line);
  }
};

// src/main.ts
var KeyValueListPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.parser = new ListParser(this);
    new KeyValueList(this, this.parser).load();
    this.addSettingTab(new SettingTab(this.app, this));
    this.registerEvent(
      this.app.metadataCache.on("changed", () => {
        this.renderPreviewMode();
      })
    );
  }
  renderPreviewMode() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      view.previewMode.rerender(true);
    }
  }
  refresh() {
    this.app.workspace.updateOptions();
    this.parser.update();
    this.renderPreviewMode();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2tleS12YWx1ZS1saXN0LnRzIiwgInNyYy93aWRnZXRzLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvbGlzdC50cyIsICJzcmMvdXRpbHMudHMiLCAic3JjL2xpc3QtcGFyc2VyLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJpbXBvcnQgeyBNYXJrZG93blZpZXcsIFBsdWdpbiB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgS2V5VmFsdWVMaXN0IH0gZnJvbSBcInNyYy9rZXktdmFsdWUtbGlzdFwiO1xuXG5pbXBvcnQge1xuICBERUZBVUxUX1NFVFRJTkdTLFxuICBLZXlWYWx1ZUxpc3RQbHVnaW5TZXR0aW5ncyxcbiAgU2V0dGluZ1RhYixcbn0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IExpc3RQYXJzZXIgfSBmcm9tIFwiLi9saXN0LXBhcnNlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlWYWx1ZUxpc3RQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogS2V5VmFsdWVMaXN0UGx1Z2luU2V0dGluZ3M7XG4gIHBhcnNlcjogTGlzdFBhcnNlcjtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICB0aGlzLnBhcnNlciA9IG5ldyBMaXN0UGFyc2VyKHRoaXMpO1xuICAgIG5ldyBLZXlWYWx1ZUxpc3QodGhpcywgdGhpcy5wYXJzZXIpLmxvYWQoKTtcblxuICAgIC8vIEFkZCBhIHNldHRpbmdzIHRhYlxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcImNoYW5nZWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbmRlclByZXZpZXdNb2RlKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICByZW5kZXJQcmV2aWV3TW9kZSgpIHtcbiAgICAvLyBUcmlnZ2VyIGEgcmUtcmVuZGVyIG9mIHRoZSBjdXJyZW50IG5vdGUgd2hlbiB0aGUgc2V0dGluZ3MgY2hhbmdlXG4gICAgLy8gdG8gZm9yY2UgdGhlIHJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yIHRvIHJlcHJvY2VzcyB0aGUgTWFya2Rvd24uXG4gICAgY29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHZpZXcucHJldmlld01vZGUucmVyZW5kZXIodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLmFwcC53b3Jrc3BhY2UudXBkYXRlT3B0aW9ucygpO1xuICAgIHRoaXMucGFyc2VyLnVwZGF0ZSgpO1xuICAgIHRoaXMucmVuZGVyUHJldmlld01vZGUoKTtcbiAgfVxuXG4gIG9udW5sb2FkKCkge31cblxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gIH1cblxuICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IExpbmUgfSBmcm9tIFwiQGNvZGVtaXJyb3IvbGFuZ3VhZ2VcIjtcbmltcG9ydCB7IFJhbmdlU2V0QnVpbGRlciB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xuaW1wb3J0IHsgRWRpdG9yUG9zaXRpb24sIE1hcmtkb3duVmlldywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW1wb3J0IHtcbiAgRGVjb3JhdGlvbixcbiAgRGVjb3JhdGlvblNldCxcbiAgRWRpdG9yVmlldyxcbiAgUGx1Z2luVmFsdWUsXG4gIFZpZXdQbHVnaW4sXG4gIFZpZXdVcGRhdGUsXG59IGZyb20gXCJAY29kZW1pcnJvci92aWV3XCI7XG5pbXBvcnQgeyBFZGl0b3IsIGVkaXRvckluZm9GaWVsZCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEtleVZhbHVlTGlzdFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5pbXBvcnQgeyBMaXN0IH0gZnJvbSBcIi4vbGlzdFwiO1xuaW1wb3J0IHsgTGlzdEl0ZW1XaWR0aCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBLZXlWYWx1ZUxpbmVXaWRnZXQgfSBmcm9tIFwiLi93aWRnZXRzXCI7XG5pbXBvcnQgeyBMaXN0UGFyc2VyIH0gZnJvbSBcIi4vbGlzdC1wYXJzZXJcIjtcblxuY29uc3QgZXhjbHVkZUZpbGVGcm9tQ3NzQ2xhc3NlcyA9IChwbHVnaW46IEtleVZhbHVlTGlzdFBsdWdpbikgPT4ge1xuICBjb25zdCBub3RlRmlsZTogVEZpbGUgfCBudWxsID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuICBpZiAobm90ZUZpbGUpIHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHBsdWdpbi5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUobm90ZUZpbGUpO1xuICAgIGlmIChtZXRhZGF0YT8uZnJvbnRtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAobWV0YWRhdGEuZnJvbnRtYXR0ZXIuY3NzY2xhc3NlcyB8fCBbXSkuaW5jbHVkZXMoXCJub2tleXZhbHVlXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY2xhc3MgS2V5VmFsdWVMaXN0IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwbHVnaW46IEtleVZhbHVlTGlzdFBsdWdpbiwgcHJpdmF0ZSBwYXJzZXI6IExpc3RQYXJzZXIpIHt9XG5cbiAgYXN5bmMgbG9hZCgpIHtcbiAgICBjb25zdCBwbHVnaW46IEtleVZhbHVlTGlzdFBsdWdpbiA9IHRoaXMucGx1Z2luO1xuICAgIGNvbnN0IHBhcnNlcjogTGlzdFBhcnNlciA9IHRoaXMucGFyc2VyO1xuXG4gICAgLy8gUmVnaXN0ZXIgYSBNYXJrZG93biBwb3N0IHByb2Nlc3NvciB0byBoYW5kbGUgcmVhZCBtb2RlLlxuICAgIHRoaXMucGx1Z2luLnJlZ2lzdGVyTWFya2Rvd25Qb3N0UHJvY2Vzc29yKChlbGVtZW50LCBjb250ZXh0KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLnBsdWdpbi5zZXR0aW5ncy5hY3RpdmVJblJlYWRNb2RlIHx8XG4gICAgICAgIGV4Y2x1ZGVGaWxlRnJvbUNzc0NsYXNzZXMocGx1Z2luKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGlzdEVsZW1lbnRzID0gZWxlbWVudC5maW5kQWxsKFwidWxcIik7XG4gICAgICBjb25zdCBkaXNwbGF5QnVsbGV0Q2hhcjogc3RyaW5nID1cbiAgICAgICAgcGx1Z2luLnNldHRpbmdzLmRpc3BsYXlCdWxsZXRDaGFyIHx8IFwiLVwiO1xuXG4gICAgICBmb3IgKGNvbnN0IGxpc3RFbGVtZW50IG9mIGxpc3RFbGVtZW50cykge1xuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSBsaXN0RWxlbWVudC5maW5kQWxsKFwibGlcIik7XG4gICAgICAgIGNvbnN0IGlzS2V5VmFsdWVMaXN0ID0gbGlzdEl0ZW1zLmV2ZXJ5KChsaXN0SXRlbSkgPT5cbiAgICAgICAgICBwYXJzZXIuaXNLZXlWYWx1ZUxpRWxlbShsaXN0SXRlbS5pbm5lclRleHQudHJpbSgpKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0tleVZhbHVlTGlzdCkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGxpc3Qgd2l0aCBhIHRhYmxlIHdoZXJlIGV2ZXJ5IHJvdyBpcyBhIGxpc3QgaXRlbSwgYW5kIHRoZSBmaXJzdCBjb2x1bW4gaXMgdGhlIGtleSBhbmQgdGhlIHNlY29uZCBjb2x1bW4gaXMgdGhlIHZhbHVlLlxuICAgICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpO1xuICAgICAgICAgIHRhYmxlLmNsYXNzTGlzdC5hZGQoXCJrdmwtdGFibGVcIik7XG4gICAgICAgICAgbGlzdEVsZW1lbnQucmVwbGFjZVdpdGgodGFibGUpO1xuICAgICAgICAgIGxldCByb3dJbmRleCA9IDA7XG4gICAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuXG4gICAgICAgICAgICAvLyBFdmVyeSBvdGhlciByb3cgc2hvdWxkIGhhdmUgYSBkaWZmZXJlbnQgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgICAgIGlmICgrK3Jvd0luZGV4ICUgMiA9PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFNldCB0aGUgYmFja2dyb3VuZCBjb2xvciB0byB0aGUgc3RyaXBlZEJhY2tncm91bmRDb2xvciBzZXR0aW5nXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3Muc3RyaXBlZEJhY2tncm91bmRUeXBlID09PSBcImN1c3RvbVwiICYmXG4gICAgICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLnN0cmlwZWRCYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdHIuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICAgICAgICAgIHBsdWdpbi5zZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoXCJrdmwtcm93LWV2ZW5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ci5jbGFzc0xpc3QuYWRkKFwia3ZsLXJvdy1vZGRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgICAgIGNvbnN0IHRkS2V5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGRLZXkpO1xuXG4gICAgICAgICAgICBsZXQga2V5VGV4dCA9IHBhcnNlci5nZXRLZXlGcm9tTGlFbGVtKGxpc3RJdGVtLmlubmVySFRNTC50cmltKCkpO1xuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgZGVsaW1pdGVyIGlmIHRoZSBzZXR0aW5ncy5kaXNwbGF5RGVsaW1pdGVyIGlzIHRydWUuXG4gICAgICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzLmRpc3BsYXlEZWxpbWl0ZXIpIHtcbiAgICAgICAgICAgICAga2V5VGV4dCArPSBwbHVnaW4uc2V0dGluZ3MuZGVsaW1pdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgYnVsbGV0IGlmIHRoZSBzZXR0aW5ncy5kaXNwbGF5QnVsbGV0IGlzIHRydWUuXG4gICAgICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzLmRpc3BsYXlCdWxsZXQpIHtcbiAgICAgICAgICAgICAga2V5VGV4dCA9IGAke2Rpc3BsYXlCdWxsZXRDaGFyfSAke2tleVRleHR9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNldHRpbmdzLmJvbGRLZXkgaXMgdHJ1ZSwgd3JhcCB0aGUga2V5IGluIGEgc3Ryb25nIHRhZy5cbiAgICAgICAgICAgIGNvbnN0IGtleUVsZW1UeXBlOiBzdHJpbmcgPSBwbHVnaW4uc2V0dGluZ3MuYm9sZEtleVxuICAgICAgICAgICAgICA/IFwic3Ryb25nXCJcbiAgICAgICAgICAgICAgOiBcInNwYW5cIjtcbiAgICAgICAgICAgIGNvbnN0IGtleUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGtleUVsZW1UeXBlKTtcbiAgICAgICAgICAgIGtleUVsZW0uaW5uZXJIVE1MID0ga2V5VGV4dDtcbiAgICAgICAgICAgIGlmIChwbHVnaW4uc2V0dGluZ3MuaXNLZXlDb2xvcmVkKSB7XG4gICAgICAgICAgICAgIGtleUVsZW0uc3R5bGUuY29sb3IgPSBwbHVnaW4uc2V0dGluZ3Mua2V5Q29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZEtleS5zdHlsZS5wYWRkaW5nID0gYCR7cGx1Z2luLnNldHRpbmdzLnZlcnRpY2FsUGFkZGluZyArIDJ9cHggJHtcbiAgICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLmhvcml6b250YWxQYWRkaW5nXG4gICAgICAgICAgICB9cHhgO1xuICAgICAgICAgICAgdGRLZXkuYXBwZW5kQ2hpbGQoa2V5RWxlbSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRkVmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICB0ZFZhbHVlLmlubmVySFRNTCA9IHBhcnNlci5nZXRWYWx1ZUZyb21MaUVsZW0oXG4gICAgICAgICAgICAgIGxpc3RJdGVtLmlubmVySFRNTC50cmltKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0ZFZhbHVlLnN0eWxlLnBhZGRpbmcgPSBgJHtwbHVnaW4uc2V0dGluZ3MudmVydGljYWxQYWRkaW5nICsgMn1weCAke1xuICAgICAgICAgICAgICBwbHVnaW4uc2V0dGluZ3MuaG9yaXpvbnRhbFBhZGRpbmdcbiAgICAgICAgICAgIH1weGA7XG4gICAgICAgICAgICBpZiAocGx1Z2luLnNldHRpbmdzLmlzVmFsdWVDb2xvcmVkKSB7XG4gICAgICAgICAgICAgIHRkVmFsdWUuc3R5bGUuY29sb3IgPSBwbHVnaW4uc2V0dGluZ3MudmFsdWVDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVnaXN0ZXIgYSBDb2RlTWlycm9yIHZpZXcgcGx1Z2luIHRvIGhhbmRsZSBlZGl0IG1vZGUuXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oXG4gICAgICBWaWV3UGx1Z2luLmZyb21DbGFzcyhcbiAgICAgICAgY2xhc3MgS1ZMUGx1Z2luIGltcGxlbWVudHMgUGx1Z2luVmFsdWUge1xuICAgICAgICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xuICAgICAgICAgIHBhcnNlcjogTGlzdFBhcnNlcjtcbiAgICAgICAgICB2aWV3OiBFZGl0b3JWaWV3O1xuICAgICAgICAgIGxpc3RXaWR0aHM6IExpc3RJdGVtV2lkdGhbXTtcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvcjtcbiAgICAgICAgICBsYXN0VG91Y2hlZExpc3RJbmRleDogbnVtYmVyO1xuICAgICAgICAgIHVwZGF0ZUNvdW50ZXI6IG51bWJlcjtcblxuICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXc6IEVkaXRvclZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmxpc3RXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRvdWNoZWRMaXN0SW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY29yYXRpb25zKHZpZXcsIFtdKTtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBFZGl0b3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcml2YXRlIHNldHVwRWRpdG9yID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoZWRpdG9ySW5mb0ZpZWxkKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZWRpdG9yIGZyb20gdGhlIGZpZWxkIGJ1dCBjYXRjaCBhbnkgdHlwZSBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWRpdG9yIGlzIG5vdCBhdmFpbGFibGUgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICBsZXQgZWRpdG9yO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZWRpdG9yID0gZmllbGQuZWRpdG9yO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgZWRpdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLnNldHVwRWRpdG9yLCAwKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50ZXIgPSAxMDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdXBkYXRlKHVwZGF0ZTogVmlld1VwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhdGhpcy5lZGl0b3IgfHxcbiAgICAgICAgICAgICAgIXBsdWdpbi5zZXR0aW5ncy5hY3RpdmVJbkVkaXRNb2RlIHx8XG4gICAgICAgICAgICAgIGV4Y2x1ZGVGaWxlRnJvbUNzc0NsYXNzZXMocGx1Z2luKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgbGlzdHMgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICAgICAgICBjb25zdCBsaXN0czogTGlzdFtdID1cbiAgICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIHRoaXMudmlldy52aXNpYmxlUmFuZ2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICA/IHBhcnNlclxuICAgICAgICAgICAgICAgICAgICAuY29sbGVjdExpc3RzKFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZnNldFRvUG9zKHRoaXMudmlldy52aWV3cG9ydC5mcm9tKS5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9mZnNldFRvUG9zKHRoaXMudmlldy52aWV3cG9ydC50bykubGluZVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGxpc3Q6IExpc3QpID0+IGxpc3QuaXNLZXlWYWx1ZUxpc3QpXG4gICAgICAgICAgICAgICAgOiBbXTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIG51bWJlciBvZiBsaXN0cyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBsaXN0IHdpZHRocy5cbiAgICAgICAgICAgIGlmIChsaXN0cy5sZW5ndGggIT0gdGhpcy5saXN0V2lkdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aGlzLmxpc3RXaWR0aHMgPSBsaXN0cy5tYXAoKCkgPT4gKHtcbiAgICAgICAgICAgICAgICBrZXk6IDAsXG4gICAgICAgICAgICAgICAgcm93OiAwLFxuICAgICAgICAgICAgICAgIGtleU5lZWRzVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJvd05lZWRzVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIGEgbGlzdC5cbiAgICAgICAgICAgIGNvbnN0IHRvdWNoZWRMaXN0SW5kZXg6IG51bWJlciA9IGxpc3RzLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgKGxpc3QpID0+IGxpc3QuaGFzQ3Vyc29ySW5zaWRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgaXNBbnlMaXN0VG91Y2hlZDogYm9vbGVhbiA9IHRvdWNoZWRMaXN0SW5kZXggPj0gMDtcbiAgICAgICAgICAgIGlmICghaXNBbnlMaXN0VG91Y2hlZCAmJiB0aGlzLmxhc3RUb3VjaGVkTGlzdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5saXN0V2lkdGhzW3RoaXMubGFzdFRvdWNoZWRMaXN0SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0V2lkdGhzW3RoaXMubGFzdFRvdWNoZWRMaXN0SW5kZXhdLmtleU5lZWRzVXBkYXRlID1cbiAgICAgICAgICAgICAgICAgIHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0V2lkdGhzW3RoaXMubGFzdFRvdWNoZWRMaXN0SW5kZXhdLnJvd05lZWRzVXBkYXRlID1cbiAgICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMubGFzdFRvdWNoZWRMaXN0SW5kZXggPSAtMTtcblxuICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBjdXJzb3IgbGVhdmVzIGEgbGlzdCwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGRlY29yYXRpb25zXG4gICAgICAgICAgICAgIC8vIHR3byBhZGRpdGlvbmFsIHRpbWVzLiBPbmUgdG8gZW5zdXJlIHByb3BlciBrZXkgd2lkdGggYW5kIG9uZSBmb3JcbiAgICAgICAgICAgICAgLy8gdGhlIHJvdyB3aWR0aC5cbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb3VudGVyID0gMztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBbnlMaXN0VG91Y2hlZCkge1xuICAgICAgICAgICAgICB0aGlzLmxhc3RUb3VjaGVkTGlzdEluZGV4ID0gdG91Y2hlZExpc3RJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB1cGRhdGUuZG9jQ2hhbmdlZCB8fFxuICAgICAgICAgICAgICB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgIGlzQW55TGlzdFRvdWNoZWQgfHxcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb3VudGVyIHx8XG4gICAgICAgICAgICAgIHBhcnNlci5uZWVkc1VwZGF0ZVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZUNvdW50ZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb3VudGVyLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBhcnNlci5uZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjb3JhdGlvbnModXBkYXRlLnZpZXcsIGxpc3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRMaXN0V2lkdGhzKGxpc3RzOiBMaXN0W10pIHtcbiAgICAgICAgICAgIGxpc3RzLmZvckVhY2goKF9saXN0OiBMaXN0LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbWF4IHdpZHRoIG9mIHRoZSBrZXkgYW5kIHRoZSByb3cgZm9yIGV2ZXJ5IGxpbmUgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgIHRoaXMubGlzdFdpZHRoc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAga2V5OiBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgIHRoaXMubGlzdFdpZHRoc1tpbmRleF0ua2V5TmVlZHNVcGRhdGVcbiAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5saXN0V2lkdGhzW2luZGV4XS5rZXksXG4gICAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGBrdmwta2V5LWlubmVyLSR7aW5kZXh9YClcbiAgICAgICAgICAgICAgICAgICkubWFwKChlbGVtKSA9PiBlbGVtLmNsaWVudFdpZHRoICsgMjApXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICByb3c6IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgdGhpcy5saXN0V2lkdGhzW2luZGV4XS5yb3dOZWVkc1VwZGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmxpc3RXaWR0aHNbaW5kZXhdLnJvdyxcbiAgICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20oXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYGt2bC1yb3ctaW5uZXItJHtpbmRleH1gKVxuICAgICAgICAgICAgICAgICAgKS5tYXAoXG4gICAgICAgICAgICAgICAgICAgIChlbGVtKSA9PlxuICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGRyZW5bMF0uY2xpZW50V2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGRyZW5bMV0uY2xpZW50V2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zZXR0aW5ncy5ob3Jpem9udGFsUGFkZGluZyAqIDJcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGtleU5lZWRzVXBkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByb3dOZWVkc1VwZGF0ZTogdGhpcy5saXN0V2lkdGhzW2luZGV4XS5rZXlOZWVkc1VwZGF0ZSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1aWxkRGVjb3JhdGlvbnModmlldzogRWRpdG9yVmlldywgbGlzdHM6IExpc3RbXSk6IERlY29yYXRpb25TZXQge1xuICAgICAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXI8RGVjb3JhdGlvbj4oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IgfHwgZXhjbHVkZUZpbGVGcm9tQ3NzQ2xhc3NlcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3Vyc29yOiBFZGl0b3JQb3NpdGlvbiA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaXN0V2lkdGhzKGxpc3RzKTtcblxuICAgICAgICAgICAgY29uc3QgbWF4S2V5V2lkdGg6IG51bWJlciA9XG4gICAgICAgICAgICAgIChwbHVnaW4uc2V0dGluZ3MubWF4S2V5V2lkdGggLyAxMDApICogdmlldy5kb20uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBjb25zdCBtYXJrZG93blZpZXcgPVxuICAgICAgICAgICAgICBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG5cbiAgICAgICAgICAgIGxpc3RzLmZvckVhY2goKGxpc3Q6IExpc3QsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBsZXQgbGluZU51bWJlcjogbnVtYmVyID0gbGlzdC5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPCBsaXN0LmVuZC5saW5lO1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIrK1xuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZU51bWJlciA9PT0gY3Vyc29yLmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lOiBMaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZShsaW5lTnVtYmVyICsgMSk7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoXG4gICAgICAgICAgICAgICAgICBsaW5lLmZyb20sXG4gICAgICAgICAgICAgICAgICBsaW5lLnRvLFxuICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0OiBuZXcgS2V5VmFsdWVMaW5lV2lkZ2V0KFxuICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmUudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhLZXlXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RXaWR0aHNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duVmlldz8uZmlsZT8ucGF0aCB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHZhbHVlKSA9PlxuICAgICAgICAgICAgcGx1Z2luLnNldHRpbmdzLmFjdGl2ZUluRWRpdE1vZGUgJiZcbiAgICAgICAgICAgICFleGNsdWRlRmlsZUZyb21Dc3NDbGFzc2VzKHBsdWdpbilcbiAgICAgICAgICAgICAgPyB2YWx1ZS5kZWNvcmF0aW9uc1xuICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZSxcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBhc3luYyB1bmxvYWQoKSB7fVxufVxuIiwgImltcG9ydCB7IFdpZGdldFR5cGUgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuaW1wb3J0IHsgTGlzdEl0ZW1XaWR0aCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgS2V5VmFsdWVMaXN0UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IE1hcmtkb3duUmVuZGVyZXIgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IEtleVZhbHVlTGlzdFBsdWdpblNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcblxuZXhwb3J0IGNsYXNzIEtleVZhbHVlTGluZVdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBwbHVnaW46IEtleVZhbHVlTGlzdFBsdWdpbixcbiAgICByZWFkb25seSBsaXN0SWQ6IG51bWJlcixcbiAgICByZWFkb25seSBsaXN0SW5kZXg6IG51bWJlcixcbiAgICByZWFkb25seSB0ZXh0TGluZTogc3RyaW5nLFxuICAgIHJlYWRvbmx5IG1heEtleVdpZHRoOiBudW1iZXIsXG4gICAgcmVhZG9ubHkgbGlzdEl0ZW1XaWR0aDogTGlzdEl0ZW1XaWR0aCxcbiAgICByZWFkb25seSBwYXRoOiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGVxKG90aGVyOiBLZXlWYWx1ZUxpbmVXaWRnZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5saXN0SWQgPT09IG90aGVyLmxpc3RJZCAmJlxuICAgICAgdGhpcy5saXN0SW5kZXggPT09IG90aGVyLmxpc3RJbmRleCAmJlxuICAgICAgdGhpcy50ZXh0TGluZSA9PT0gb3RoZXIudGV4dExpbmUgJiZcbiAgICAgIHRoaXMubWF4S2V5V2lkdGggPT09IG90aGVyLm1heEtleVdpZHRoICYmXG4gICAgICB0aGlzLmxpc3RJdGVtV2lkdGggPT09IG90aGVyLmxpc3RJdGVtV2lkdGggJiZcbiAgICAgIHRoaXMucGF0aCA9PT0gb3RoZXIucGF0aFxuICAgICk7XG4gIH1cblxuICB0b0RPTSgpIHtcbiAgICBjb25zdCBzZXR0aW5nczogS2V5VmFsdWVMaXN0UGx1Z2luU2V0dGluZ3MgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncztcbiAgICBjb25zdCBidWxsZXQgPSBcIi1cIjtcbiAgICBjb25zdCBkaXNwbGF5QnVsbGV0Q2hhcjogc3RyaW5nID0gc2V0dGluZ3MuZGlzcGxheUJ1bGxldENoYXIgfHwgXCItXCI7XG4gICAgY29uc3QgZGVsaW1pdGVyOiBzdHJpbmcgPSBzZXR0aW5ncy5kZWxpbWl0ZXIgfHwgXCI6XCI7XG4gICAgY29uc3QgaXNFdmVuOiBib29sZWFuID0gdGhpcy5saXN0SW5kZXggJSAyID09IDA7XG4gICAgY29uc3Qgc3BsaXQ6IG51bWJlciA9IHRoaXMudGV4dExpbmUuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgIGxldCBrZXkgPSBgJHtcbiAgICAgIHNldHRpbmdzLmRpc3BsYXlCdWxsZXQgPyBgXFxcXCR7ZGlzcGxheUJ1bGxldENoYXJ9IGAgOiBcIlwiXG4gICAgfSR7dGhpcy50ZXh0TGluZVxuICAgICAgLnN1YnN0cmluZyhcbiAgICAgICAgYnVsbGV0Lmxlbmd0aCArIDEsXG4gICAgICAgIHNwbGl0ICsgKHNldHRpbmdzLmRpc3BsYXlEZWxpbWl0ZXIgPyBkZWxpbWl0ZXIubGVuZ3RoIDogMClcbiAgICAgIClcbiAgICAgIC50cmltKCl9YDtcblxuICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHJvd3Mgc3RhcnRpbmcgd2l0aCBhIGNoZWNrYm94XG4gICAgaWYgKCFzZXR0aW5ncy5kaXNwbGF5QnVsbGV0ICYmIGtleS5jaGFyQXQoMCkgPT09IFwiW1wiKSB7XG4gICAgICBrZXkgPSBgLSAke2tleX1gO1xuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZGlzcGxheUJ1bGxldCAmJiBrZXkuc3RhcnRzV2l0aChcIlxcXFwtIFtcIikpIHtcbiAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgbGV0IHZhbHVlOiBzdHJpbmcgPSB0aGlzLnRleHRMaW5lXG4gICAgICAuc3Vic3RyaW5nKHNwbGl0ICsgZGVsaW1pdGVyLmxlbmd0aClcbiAgICAgIC50cmltKCk7XG5cbiAgICAvLyBDb250YWluZXJcbiAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICByb3cuaWQgPSBga3ZsLSR7dGhpcy5saXN0SWR9LSR7dGhpcy5saXN0SW5kZXh9YDtcbiAgICByb3cuY2xhc3NOYW1lID0gYGt2bC1yb3cga3ZsLXJvdy0ke3RoaXMubGlzdElkfSAke1xuICAgICAgaXNFdmVuID8gXCJrdmwtcm93LWV2ZW5cIiA6IFwia3ZsLXJvdy1vZGRcIlxuICAgIH0gJHtzZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZFR5cGUgPT09IFwiZGVmYXVsdFwiID8gXCJzdHJpcGVkXCIgOiBcIlwifWA7XG4gICAgaWYgKGlzRXZlbiAmJiBzZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZFR5cGUgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgIHJvdy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZENvbG9yO1xuICAgIH1cbiAgICByb3cuc3R5bGUucGFkZGluZyA9IGAke3NldHRpbmdzLnZlcnRpY2FsUGFkZGluZ31weCAke3NldHRpbmdzLmhvcml6b250YWxQYWRkaW5nfXB4YDtcbiAgICBpZiAodGhpcy5saXN0SXRlbVdpZHRoLnJvdykge1xuICAgICAgcm93LnN0eWxlLm1pbldpZHRoID0gYCR7dGhpcy5saXN0SXRlbVdpZHRoLnJvd31weGA7XG4gICAgfVxuXG4gICAgY29uc3Qgcm93SW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICByb3dJbm5lci5jbGFzc05hbWUgPSBga3ZsLXJvdy1pbm5lciBrdmwtcm93LWlubmVyLSR7dGhpcy5saXN0SWR9YDtcblxuICAgIC8vIEtleVxuICAgIGNvbnN0IGtleVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgc2V0dGluZ3MuYm9sZEtleSA/IFwic3Ryb25nXCIgOiBcInNwYW5cIlxuICAgICk7XG4gICAga2V5U3Bhbi5jbGFzc05hbWUgPSBga3ZsLWtleSBrdmwta2V5LSR7dGhpcy5saXN0SWR9YDtcbiAgICBpZiAodGhpcy5saXN0SXRlbVdpZHRoLmtleSkge1xuICAgICAga2V5U3Bhbi5zdHlsZS5taW5XaWR0aCA9IGAke3RoaXMubGlzdEl0ZW1XaWR0aC5rZXl9cHhgO1xuICAgIH1cblxuICAgIGNvbnN0IGtleVNwYW5Jbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGlmICh0aGlzLm1heEtleVdpZHRoID4gMCkge1xuICAgICAga2V5U3BhbklubmVyLnN0eWxlLm1heFdpZHRoID0gYCR7dGhpcy5tYXhLZXlXaWR0aH1weGA7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5pc0tleUNvbG9yZWQpIHtcbiAgICAgIGtleVNwYW5Jbm5lci5zdHlsZS5jb2xvciA9IHNldHRpbmdzLmtleUNvbG9yO1xuICAgIH1cbiAgICBrZXlTcGFuSW5uZXIuY2xhc3NOYW1lID0gYGt2bC1rZXktaW5uZXIga3ZsLWtleS1pbm5lci0ke3RoaXMubGlzdElkfWA7XG4gICAgdGhpcy5yZW5kZXJNYXJrZG93bihrZXksIGtleVNwYW5Jbm5lcik7XG5cbiAgICAvLyBWYWx1ZVxuICAgIGNvbnN0IHZhbHVlU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHZhbHVlU3Bhbi5jbGFzc05hbWUgPSBcImt2bC12YWx1ZVwiO1xuICAgIGlmIChzZXR0aW5ncy5pc1ZhbHVlQ29sb3JlZCkge1xuICAgICAgdmFsdWVTcGFuLnN0eWxlLmNvbG9yID0gc2V0dGluZ3MudmFsdWVDb2xvcjtcbiAgICB9XG5cbiAgICAvLyBFc2NhcGUgYW55IGZvb3Rub3RlcyBpbiB0aGUgdmFsdWUuIEEgZm9vdCBub3RlIGlzIGEgbnVtYmVyIGFmdGVyIHRoZSBeIHN5bWJvbCBpbiBzcXVhcmUgYnJhY2tldHMuXG4gICAgLy8gRXhhbXBsZTogVGhpcyBpcyBhIGZvb3Rub3RlW14xXVxuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxbKFxcXlxcZCspXFxdL2csIFwiXFxcXCQxXCIpO1xuXG4gICAgdGhpcy5yZW5kZXJNYXJrZG93bih2YWx1ZSwgdmFsdWVTcGFuKTtcblxuICAgIHJvdy5hcHBlbmRDaGlsZChyb3dJbm5lcik7XG4gICAgcm93SW5uZXIuYXBwZW5kQ2hpbGQoa2V5U3Bhbik7XG4gICAga2V5U3Bhbi5hcHBlbmRDaGlsZChrZXlTcGFuSW5uZXIpO1xuICAgIHJvd0lubmVyLmFwcGVuZENoaWxkKHZhbHVlU3Bhbik7XG4gICAgcmV0dXJuIHJvdztcbiAgfVxuXG4gIHJlbmRlck1hcmtkb3duKGh0bWw6IHN0cmluZywgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xuICAgIE1hcmtkb3duUmVuZGVyZXIucmVuZGVyKFxuICAgICAgdGhpcy5wbHVnaW4uYXBwLFxuICAgICAgaHRtbCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHRoaXMucGF0aCxcbiAgICAgIHRoaXMucGx1Z2luXG4gICAgKTtcbiAgfVxuXG4gIGlnbm9yZUV2ZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEFwcCxcbiAgQnV0dG9uQ29tcG9uZW50LFxuICBDb2xvckNvbXBvbmVudCxcbiAgUGx1Z2luU2V0dGluZ1RhYixcbiAgU2V0dGluZyxcbiAgU2xpZGVyQ29tcG9uZW50LFxuICBUZXh0Q29tcG9uZW50LFxuICBUb2dnbGVDb21wb25lbnQsXG59IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEtleVZhbHVlTGlzdFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgS2V5VmFsdWVMaXN0UGx1Z2luU2V0dGluZ3Mge1xuICBhY3RpdmVJbkVkaXRNb2RlOiBib29sZWFuO1xuICBhY3RpdmVJblJlYWRNb2RlOiBib29sZWFuO1xuICBkaXNwbGF5QnVsbGV0OiBib29sZWFuO1xuICBkaXNwbGF5QnVsbGV0Q2hhcjogc3RyaW5nO1xuICBkZWxpbWl0ZXI6IHN0cmluZztcbiAgZGlzcGxheURlbGltaXRlcjogYm9vbGVhbjtcbiAgbWF4S2V5V2lkdGg6IG51bWJlcjtcbiAgdmVydGljYWxQYWRkaW5nOiBudW1iZXI7XG4gIGhvcml6b250YWxQYWRkaW5nOiBudW1iZXI7XG4gIGJvbGRLZXk6IGJvb2xlYW47XG4gIHN0cmlwZWRCYWNrZ3JvdW5kVHlwZTogc3RyaW5nO1xuICBzdHJpcGVkQmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gIGlzS2V5Q29sb3JlZDogYm9vbGVhbjtcbiAga2V5Q29sb3I6IHN0cmluZztcbiAgaXNWYWx1ZUNvbG9yZWQ6IGJvb2xlYW47XG4gIHZhbHVlQ29sb3I6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IEtleVZhbHVlTGlzdFBsdWdpblNldHRpbmdzID0ge1xuICBhY3RpdmVJbkVkaXRNb2RlOiB0cnVlLFxuICBhY3RpdmVJblJlYWRNb2RlOiB0cnVlLFxuICBkaXNwbGF5QnVsbGV0OiBmYWxzZSxcbiAgZGlzcGxheUJ1bGxldENoYXI6IFwiLVwiLFxuICBkZWxpbWl0ZXI6IFwiOlwiLFxuICBkaXNwbGF5RGVsaW1pdGVyOiB0cnVlLFxuICBtYXhLZXlXaWR0aDogNTAsXG4gIHZlcnRpY2FsUGFkZGluZzogMyxcbiAgaG9yaXpvbnRhbFBhZGRpbmc6IDEyLFxuICBib2xkS2V5OiB0cnVlLFxuICBzdHJpcGVkQmFja2dyb3VuZFR5cGU6IFwiZGVmYXVsdFwiLFxuICBzdHJpcGVkQmFja2dyb3VuZENvbG9yOiBcIlwiLFxuICBpc0tleUNvbG9yZWQ6IGZhbHNlLFxuICBrZXlDb2xvcjogXCJcIixcbiAgaXNWYWx1ZUNvbG9yZWQ6IGZhbHNlLFxuICB2YWx1ZUNvbG9yOiBcIlwiLFxufTtcblxuZXhwb3J0IGNsYXNzIFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBLZXlWYWx1ZUxpc3RQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogS2V5VmFsdWVMaXN0UGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb25zdCBmb2xkYWJsZVBhZGRpbmcgPSA0MjtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJBY3RpdmUgaW4gZWRpdCBtb2RlXCIpXG4gICAgICAuc2V0RGVzYyhcIklmIHRoZSBwbHVnaW4gc2hvdWxkIGJlIGFjdGl2ZSBpbiBlZGl0IG1vZGVcIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZTogVG9nZ2xlQ29tcG9uZW50KSA9PlxuICAgICAgICB0b2dnbGVcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYWN0aXZlSW5FZGl0TW9kZSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hY3RpdmVJbkVkaXRNb2RlID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQWN0aXZlIGluIHJlYWQgbW9kZVwiKVxuICAgICAgLnNldERlc2MoXCJJZiB0aGUgcGx1Z2luIHNob3VsZCBiZSBhY3RpdmUgaW4gcmVhZCBtb2RlXCIpXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGU6IFRvZ2dsZUNvbXBvbmVudCkgPT5cbiAgICAgICAgdG9nZ2xlXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFjdGl2ZUluUmVhZE1vZGUpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYWN0aXZlSW5SZWFkTW9kZSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVmcmVzaCgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkRpc3BsYXkgYnVsbGV0XCIpXG4gICAgICAuc2V0RGVzYyhcIklmIHRoZSBidWxsZXQgc2hvdWxkIGJlIGRpc3BsYXllZCBvciBub3RcIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZTogVG9nZ2xlQ29tcG9uZW50KSA9PlxuICAgICAgICB0b2dnbGVcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGlzcGxheUJ1bGxldClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBkaXNwbGF5QnVsbGV0Q2hhci5zZXR0aW5nRWwudG9nZ2xlQ2xhc3MoXCJkaXNhYmxlZFwiLCAhdmFsdWUpO1xuICAgICAgICAgICAgZGlzcGxheUJ1bGxldENoYXIuc2V0dGluZ0VsLnN0eWxlLmhlaWdodCA9IHZhbHVlXG4gICAgICAgICAgICAgID8gYCR7ZGlzcGxheUJ1bGxldENoYXIuc2V0dGluZ0VsLmlubmVySGVpZ2h0ICsgZm9sZGFibGVQYWRkaW5nfXB4YFxuICAgICAgICAgICAgICA6IFwiMHB4XCI7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNwbGF5QnVsbGV0ID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBjb25zdCBkaXNwbGF5QnVsbGV0Q2hhciA9IG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJCdWxsZXQgY2hhcmFjdGVyXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJUaGUgY2hhcmFjdGVyKHMpIHRvIGJlIGRpc3BsYXllZCBmb3IgYnVsbGV0cy4gVGhlIHRyaWdnZXIgYnVsbGV0IHdpbGwgYWx3YXlzIGJlIGEgZGFzaCAoLSkgcmVnYXJkbGVzcyBvZiB0aGlzIHNldHRpbmcuXCJcbiAgICAgIClcbiAgICAgIC5zZXRDbGFzcyhcImZvbGRhYmxlLXNldHRpbmdcIilcbiAgICAgIC5zZXRDbGFzcyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNwbGF5QnVsbGV0ID8gXCJlbmFibGVkXCIgOiBcImRpc2FibGVkXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dDogVGV4dENvbXBvbmVudCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1NFVFRJTkdTLmRpc3BsYXlCdWxsZXRDaGFyKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNwbGF5QnVsbGV0Q2hhcilcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kaXNwbGF5QnVsbGV0Q2hhciA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC50aGVuKChzZXR0aW5nKSA9PiB7XG4gICAgICAgIHNldHRpbmcuc2V0dGluZ0VsLnN0eWxlLmhlaWdodCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmRpc3BsYXlCdWxsZXRcbiAgICAgICAgICA/IGAke3NldHRpbmcuc2V0dGluZ0VsLmNsaWVudEhlaWdodH1weGBcbiAgICAgICAgICA6IFwiMHB4XCI7XG4gICAgICB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJEaXNwbGF5IGRlbGltaXRlclwiKVxuICAgICAgLnNldERlc2MoXCJJZiB0aGUgZGVsaW1pdGVyIHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGtleSBvciBub3RcIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZTogVG9nZ2xlQ29tcG9uZW50KSA9PlxuICAgICAgICB0b2dnbGVcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZGlzcGxheURlbGltaXRlcilcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBkaXNwbGF5RGVsaW1pdGVyQ2hhci5zZXR0aW5nRWwudG9nZ2xlQ2xhc3MoXCJkaXNhYmxlZFwiLCAhdmFsdWUpO1xuICAgICAgICAgICAgZGlzcGxheURlbGltaXRlckNoYXIuc2V0dGluZ0VsLnN0eWxlLmhlaWdodCA9IHZhbHVlXG4gICAgICAgICAgICAgID8gYCR7XG4gICAgICAgICAgICAgICAgICBkaXNwbGF5RGVsaW1pdGVyQ2hhci5zZXR0aW5nRWwuaW5uZXJIZWlnaHQgKyBmb2xkYWJsZVBhZGRpbmdcbiAgICAgICAgICAgICAgICB9cHhgXG4gICAgICAgICAgICAgIDogXCIwcHhcIjtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRpc3BsYXlEZWxpbWl0ZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGNvbnN0IGRpc3BsYXlEZWxpbWl0ZXJDaGFyID0gbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkRlbGltaXRlclwiKVxuICAgICAgLnNldERlc2MoXCJUaGUgY2hhcmFjdGVyKHMpIHRoYXQgc2VwYXJhdGUgdGhlIGtleSBmcm9tIHRoZSB2YWx1ZVwiKVxuICAgICAgLnNldENsYXNzKFwiZm9sZGFibGUtc2V0dGluZ1wiKVxuICAgICAgLnNldENsYXNzKHRoaXMucGx1Z2luLnNldHRpbmdzLmRpc3BsYXlEZWxpbWl0ZXIgPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0OiBUZXh0Q29tcG9uZW50KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKERFRkFVTFRfU0VUVElOR1MuZGVsaW1pdGVyKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWxpbWl0ZXIpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGVsaW1pdGVyID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnRoZW4oKHNldHRpbmcpID0+IHtcbiAgICAgICAgc2V0dGluZy5zZXR0aW5nRWwuc3R5bGUuaGVpZ2h0ID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGlzcGxheURlbGltaXRlclxuICAgICAgICAgID8gYCR7c2V0dGluZy5zZXR0aW5nRWwuY2xpZW50SGVpZ2h0fXB4YFxuICAgICAgICAgIDogXCIwcHhcIjtcbiAgICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIk1heCBrZXkgd2lkdGhcIilcbiAgICAgIC5zZXREZXNjKFxuICAgICAgICBcIk1heGltdW0gd2lkdGggb2YgdGhlIGtleSBpbiBwZXJjZW50IG9mIHRoZSBlZGl0b3Igd2lkdGguIDAgPSBubyBsaW1pdFwiXG4gICAgICApXG4gICAgICAuYWRkU2xpZGVyKChzbGlkZXI6IFNsaWRlckNvbXBvbmVudCkgPT5cbiAgICAgICAgc2xpZGVyXG4gICAgICAgICAgLnNldExpbWl0cygwLCA5OSwgMSlcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubWF4S2V5V2lkdGgpXG4gICAgICAgICAgLnNldER5bmFtaWNUb29sdGlwKClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm1heEtleVdpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiVmVydGljYWwgcGFkZGluZ1wiKVxuICAgICAgLnNldERlc2MoXCJWZXJ0aWNhbCBwYWRkaW5nIG9mIHRoZSBrZXktdmFsdWUgbGlzdCByb3dzIChpbiBwaXhlbHMpXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dDogVGV4dENvbXBvbmVudCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihERUZBVUxUX1NFVFRJTkdTLnZlcnRpY2FsUGFkZGluZy50b1N0cmluZygpKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy52ZXJ0aWNhbFBhZGRpbmc/LnRvU3RyaW5nKCkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IG51bWVyaWNWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihudW1lcmljVmFsdWUpKSB7XG4gICAgICAgICAgICAgIG51bWVyaWNWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy52ZXJ0aWNhbFBhZGRpbmcgPSBudW1lcmljVmFsdWU7XG4gICAgICAgICAgICB0ZXh0LnNldFZhbHVlKG51bWVyaWNWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVmcmVzaCgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkhvcml6b250YWwgcGFkZGluZ1wiKVxuICAgICAgLnNldERlc2MoXCJIb3Jpem9udGFsIHBhZGRpbmcgb2YgdGhlIGtleS12YWx1ZSBsaXN0IHJvd3MgKGluIHBpeGVscylcIilcbiAgICAgIC5hZGRUZXh0KCh0ZXh0OiBUZXh0Q29tcG9uZW50KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFBsYWNlaG9sZGVyKERFRkFVTFRfU0VUVElOR1MuaG9yaXpvbnRhbFBhZGRpbmcudG9TdHJpbmcoKSlcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuaG9yaXpvbnRhbFBhZGRpbmc/LnRvU3RyaW5nKCkpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IG51bWVyaWNWYWx1ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihudW1lcmljVmFsdWUpKSB7XG4gICAgICAgICAgICAgIG51bWVyaWNWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ob3Jpem9udGFsUGFkZGluZyA9IG51bWVyaWNWYWx1ZTtcbiAgICAgICAgICAgIHRleHQuc2V0VmFsdWUobnVtZXJpY1ZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQm9sZCBrZXlzXCIpXG4gICAgICAuc2V0RGVzYyhcIkl0IHRoZSBrZXlzIHNob3VsZCBiZSByZW5kZXJlZCBpbiBhIGJvbGQgZm9udFwiKVxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlOiBUb2dnbGVDb21wb25lbnQpID0+XG4gICAgICAgIHRvZ2dsZVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5ib2xkS2V5KVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmJvbGRLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGNvbnN0IGJhY2tncm91bmRDb2xvck9wdGlvbnMgPSBbXG4gICAgICB7IGtleTogXCJub25lXCIsIGxhYmVsOiBcIk5vIGJhY2tncm91bmQgY29sb3JcIiB9LFxuICAgICAgeyBrZXk6IFwiZGVmYXVsdFwiLCBsYWJlbDogXCJEZWZhdWx0IGJhY2tncm91bmQgY29sb3IgKGJhc2VkIG9uIHRoZW1lKVwiIH0sXG4gICAgICB7IGtleTogXCJjdXN0b21cIiwgbGFiZWw6IFwiQ3VzdG9tIGJhY2tncm91bmQgY29sb3JcIiB9LFxuICAgIF07XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiU3RyaXBlZCBiYWNrZ3JvdW5kXCIpXG4gICAgICAuc2V0RGVzYyhcIkNob29zZSBpZiBldmVuIHJvd3Mgc2hvdWxkIGhhdmUgYW5vdGhlciBiYWNrZ3JvdW5kIGNvbG9yXCIpXG4gICAgICAuYWRkRHJvcGRvd24oKGRyb3Bkb3duKSA9PiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvck9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgZHJvcGRvd24uYWRkT3B0aW9uKG9wdGlvbi5rZXksIG9wdGlvbi5sYWJlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkcm9wZG93bi5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZFR5cGUpO1xuICAgICAgICBkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zdHJpcGVkQmFja2dyb3VuZFR5cGUgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5KCk7XG4gICAgICAgICAgdGhpcy5wbHVnaW4ucmVmcmVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnN0cmlwZWRCYWNrZ3JvdW5kVHlwZSA9PT0gXCJjdXN0b21cIikge1xuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiU3RyaXBlZCBiYWNrZ3JvdW5kIGNvbG9yXCIpXG4gICAgICAgIC5zZXREZXNjKFwiQ2hvb3NlIHRoZSBjb2xvciBvZiB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kLlwiKVxuICAgICAgICAuYWRkQ29sb3JQaWNrZXIoKGNvbG9yOiBDb2xvckNvbXBvbmVudCkgPT5cbiAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnN0cmlwZWRCYWNrZ3JvdW5kQ29sb3IpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnN0cmlwZWRCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJDdXN0b20ga2V5IGNvbG9yXCIpXG4gICAgICAuc2V0RGVzYyhcIklmIGEgY3VzdG9tIGNvbG9yIHNob3VsZCBiZSB1c2VkIGZvciB0aGUga2V5c1wiKVxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlOiBUb2dnbGVDb21wb25lbnQpID0+XG4gICAgICAgIHRvZ2dsZVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pc0tleUNvbG9yZWQpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuaXNLZXlDb2xvcmVkID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pc0tleUNvbG9yZWQpIHtcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIktleSBjb2xvclwiKVxuICAgICAgICAuc2V0RGVzYyhcIkNob29zZSB0aGUgY29sb3Igb2YgdGhlIGtleXMuXCIpXG4gICAgICAgIC5hZGRDb2xvclBpY2tlcigoY29sb3I6IENvbG9yQ29tcG9uZW50KSA9PlxuICAgICAgICAgIGNvbG9yXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mua2V5Q29sb3IpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmtleUNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQ3VzdG9tIHZhbHVlIGNvbG9yXCIpXG4gICAgICAuc2V0RGVzYyhcIklmIGEgY3VzdG9tIGNvbG9yIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgdmFsdWVzXCIpXG4gICAgICAuYWRkVG9nZ2xlKCh0b2dnbGU6IFRvZ2dsZUNvbXBvbmVudCkgPT5cbiAgICAgICAgdG9nZ2xlXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmlzVmFsdWVDb2xvcmVkKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmlzVmFsdWVDb2xvcmVkID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5pc1ZhbHVlQ29sb3JlZCkge1xuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKFwiVmFsdWUgY29sb3JcIilcbiAgICAgICAgLnNldERlc2MoXCJDaG9vc2UgdGhlIGNvbG9yIG9mIHRoZSB2YWx1ZXMuXCIpXG4gICAgICAgIC5hZGRDb2xvclBpY2tlcigoY29sb3I6IENvbG9yQ29tcG9uZW50KSA9PlxuICAgICAgICAgIGNvbG9yXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmFsdWVDb2xvcilcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudmFsdWVDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlJlc2V0IHNldHRpbmdzXCIpXG4gICAgICAuc2V0RGVzYyhcIlJlc2V0IGFsbCBzZXR0aW5ncyB0byB0aGVpciBkZWZhdWx0IHZhbHVlc1wiKVxuICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uOiBCdXR0b25Db21wb25lbnQpID0+XG4gICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiUmVzZXQgc2V0dGluZ3NcIikub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcmVzZXQgdGhlIHNldHRpbmdzP1wiKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSgpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4ucmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBFZGl0b3JQb3NpdGlvbiB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgTGlzdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzdGFydDogRWRpdG9yUG9zaXRpb24sXG4gICAgcHVibGljIGVuZDogRWRpdG9yUG9zaXRpb24sXG4gICAgcHVibGljIGlzS2V5VmFsdWVMaXN0OiBib29sZWFuLFxuICAgIHB1YmxpYyBoYXNDdXJzb3JJbnNpZGU6IGJvb2xlYW5cbiAgKSB7fVxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nOiBzdHJpbmcpIHtcbiAgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuIiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTGlzdCB9IGZyb20gXCIuL2xpc3RcIjtcbmltcG9ydCBLZXlWYWx1ZUxpc3RQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuaW1wb3J0IHsgZXNjYXBlUmVnRXhwIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xuXG5jb25zdCBsaXN0SXRlbVJlZyA9IG5ldyBSZWdFeHAoYF5bIFxcdF0qLSguKilgKTtcblxuZXhwb3J0IGNsYXNzIExpc3RQYXJzZXIge1xuICBrZXlWYWx1ZVJlZzogUmVnRXhwO1xuICBsaUVsZW1SZWc6IFJlZ0V4cDtcbiAgbmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBsdWdpbjogS2V5VmFsdWVMaXN0UGx1Z2luKSB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBidWxsZXQgPSBcIi1cIjtcbiAgICBjb25zdCBkZWxpbWl0ZXI6IHN0cmluZyA9IGVzY2FwZVJlZ0V4cChcbiAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmRlbGltaXRlciB8fCBERUZBVUxUX1NFVFRJTkdTLmRlbGltaXRlclxuICAgICk7XG4gICAgdGhpcy5rZXlWYWx1ZVJlZyA9IG5ldyBSZWdFeHAoYF5bIFxcdF0qJHtidWxsZXR9KC4qKSR7ZGVsaW1pdGVyfSAoLiopYCk7XG4gICAgdGhpcy5saUVsZW1SZWcgPSBuZXcgUmVnRXhwKGBeKC4qKSR7ZGVsaW1pdGVyfSAoLiopYCk7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdHMgYWxsIGxpc3RzIHdpdGhpbiBhIGdpdmVuIHJhbmdlLlxuICAgKiBAcGFyYW0gIHtFZGl0b3J9IGVkaXRvciAgICBUaGUgZWRpdG9yIHRvIHBhcnNlLlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHN0YXJ0TGluZSBUaGUgbGluZSB0byBzdGFydCBwYXJzaW5nIGZyb20uXG4gICAqIEBwYXJhbSAge051bWJlcn0gZW5kTGluZSAgIFRoZSBsaW5lIHRvIHN0b3AgcGFyc2luZyBhdC5cbiAgICogQHJldHVybiB7TGlzdFtdfSAgICAgICAgICAgQSBsaXN0IG9mIGFsbCBsaXN0cyBmb3VuZC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29sbGVjdExpc3RzKFxuICAgIGVkaXRvcjogRWRpdG9yLFxuICAgIHN0YXJ0TGluZSA9IDAsXG4gICAgZW5kTGluZTogbnVtYmVyID0gZWRpdG9yLmxhc3RMaW5lKClcbiAgKTogTGlzdFtdIHtcbiAgICBjb25zdCBsaXN0czogTGlzdFtdID0gW107XG4gICAgY29uc3QgY3Vyc29yTGluZSA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXG4gICAgZm9yIChcbiAgICAgIGxldCBjdXJyZW50TGluZTogbnVtYmVyID0gc3RhcnRMaW5lO1xuICAgICAgY3VycmVudExpbmUgPD0gZW5kTGluZTtcbiAgICAgIGN1cnJlbnRMaW5lKytcbiAgICApIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJyZW50TGluZSk7XG4gICAgICBpZiAodGhpcy5pc0xpbmVMaXN0KGxpbmUpKSB7XG4gICAgICAgIGxldCBpc0tleVZhbHVlTGlzdCA9IHRydWU7XG4gICAgICAgIGxldCBoYXNDdXJzb3JJbnNpZGUgPSBmYWxzZTtcblxuICAgICAgICBsZXQgbGlzdEVuZExpbmVMb29rdXA6IG51bWJlciA9IGN1cnJlbnRMaW5lO1xuICAgICAgICB3aGlsZSAobGlzdEVuZExpbmVMb29rdXAgPD0gZWRpdG9yLmxhc3RMaW5lKCkpIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGlzdEVuZExpbmVMb29rdXApO1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBsaW5lIGlzIGEgbGlzdCBpdGVtXG4gICAgICAgICAgaWYgKCF0aGlzLmlzTGluZUxpc3QobGluZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3Vyc29yTGluZSA9PT0gbGlzdEVuZExpbmVMb29rdXApIHtcbiAgICAgICAgICAgIGhhc0N1cnNvckluc2lkZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxpc3QgaXRlbSBpcyBhIGtleS12YWx1ZSBsaXN0IGl0ZW0gKG9yIHRoZSBjdXJzb3IgaXMgb24gdGhlIGxpbmUpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMuaXNLZXlWYWx1ZUxpc3RJdGVtKGxpbmUpICYmXG4gICAgICAgICAgICBjdXJzb3JMaW5lICE9PSBsaXN0RW5kTGluZUxvb2t1cFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaXNLZXlWYWx1ZUxpc3QgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGlzdEVuZExpbmVMb29rdXAgPj0gZW5kTGluZSkge1xuICAgICAgICAgICAgbGlzdEVuZExpbmVMb29rdXAgPSBlbmRMaW5lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3RFbmRMaW5lTG9va3VwKys7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdHMucHVzaChcbiAgICAgICAgICBuZXcgTGlzdChcbiAgICAgICAgICAgIHsgbGluZTogY3VycmVudExpbmUsIGNoOiAwIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpc3RFbmRMaW5lTG9va3VwLFxuICAgICAgICAgICAgICBjaDogZWRpdG9yLmdldExpbmUobGlzdEVuZExpbmVMb29rdXApLmxlbmd0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0tleVZhbHVlTGlzdCxcbiAgICAgICAgICAgIGhhc0N1cnNvckluc2lkZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudExpbmUgPSBsaXN0RW5kTGluZUxvb2t1cDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdHM7XG4gIH1cblxuICBwcml2YXRlIGlzTGluZUxpc3QobGluZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxpc3RJdGVtUmVnLnRlc3QobGluZSk7XG4gIH1cblxuICBwdWJsaWMgaXNLZXlWYWx1ZUxpRWxlbShsaW5lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5saUVsZW1SZWcudGVzdChsaW5lKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRLZXlGcm9tTGlFbGVtKGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGxpbmUubWF0Y2godGhpcy5saUVsZW1SZWcpPy5bMV0gfHwgXCJcIjtcbiAgfVxuXG4gIHB1YmxpYyBnZXRWYWx1ZUZyb21MaUVsZW0obGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbGluZS5tYXRjaCh0aGlzLmxpRWxlbVJlZyk/LlsyXSB8fCBcIlwiO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0tleVZhbHVlTGlzdEl0ZW0obGluZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMua2V5VmFsdWVSZWcudGVzdChsaW5lKTtcbiAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQUFxQzs7O0FDQ3JDLG1CQUFnQztBQUNoQyxJQUFBQyxtQkFBb0Q7QUFFcEQsSUFBQUMsZUFPTztBQUNQLElBQUFELG1CQUF3Qzs7O0FDWnhDLGtCQUEyQjtBQUczQixzQkFBaUM7QUFHMUIsSUFBTSxxQkFBTixjQUFpQyx1QkFBVztBQUFBLEVBQ2pELFlBQ1csUUFDQSxRQUNBLFdB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O0FBQUEsTUFDaEI7QUFBQSxJQUNGO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVRLFdBQVcsTUFBYztBQUMvQixXQUFPLFlBQVksS0FBSyxJQUFJO0FBQUEsRUFDOUI7QUFBQSxFQUVPLGlCQUFpQixNQUFjO0FBQ3BDLFdBQU8sS0FBSyxVQUFVLEtBQUssSUFBSTtBQUFBLEVBQ2pDO0FBQUEsRUFFTyxpQkFBaUIsTUFBc0I7QUF4R2hEO0FBeUdJLGFBQU8sVUFBSyxNQUFNLEtBQUssU0FBUyxNQUF6QixtQkFBNkIsT0FBTTtBQUFBLEVBQzVDO0FBQUEsRUFFTyxtQkFBbUIsTUFBc0I7QUE1R2xEO0FBNkdJLGFBQU8sVUFBSyxNQUFNLEtBQUssU0FBUyxNQUF6QixtQkFBNkIsT0FBTTtBQUFBLEVBQzVDO0FBQUEsRUFFUSxtQkFBbUIsTUFBdUI7QUFDaEQsV0FBTyxLQUFLLFlBQVksS0FBSyxJQUFJO0FBQUEsRUFDbkM7QUFDRjs7O0FOekdBLElBQXFCLHFCQUFyQixjQUFnRCx3QkFBTztBQUFBLEVBSXJELE1BQU0sU0FBUztBQUNiLFVBQU0sS0FBSyxhQUFhO0FBQ3hCLFNBQUssU0FBUyxJQUFJLFdBQVcsSUFBSTtBQUNqQyxRQUFJLGFBQWEsTUFBTSxLQUFLLE1BQU0sRUFBRSxLQUFLO0FBR3pDLFNBQUssY0FBYyxJQUFJLFdBQVcsS0FBSyxLQUFLLElBQUksQ0FBQztBQUVqRCxTQUFLO0FBQUEsTUFDSCxLQUFLLElBQUksY0FBYyxHQUFHLFdBQVcsTUFBTTtBQUN6QyxhQUFLLGtCQUFrQjtBQUFBLE1BQ3pCLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUFBLEVBRUEsb0JBQW9CO0FBR2xCLFVBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxvQkFBb0IsNkJBQVk7QUFDaEUsUUFBSSxNQUFNO0FBQ1IsV0FBSyxZQUFZLFNBQVMsSUFBSTtBQUFBLElBQ2hDO0FBQUEsRUFDRjtBQUFBLEVBRUEsVUFBVTtBQUNSLFNBQUssSUFBSSxVQUFVLGNBQWM7QUFDakMsU0FBSyxPQUFPLE9BQU87QUFDbkIsU0FBSyxrQkFBa0I7QUFBQSxFQUN6QjtBQUFBLEVBRUEsV0FBVztBQUFBLEVBQUM7QUFBQSxFQUVaLE1BQU0sZUFBZTtBQUNuQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbkM7QUFDRjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfdmlldyIsICJpbXBvcnRfb2JzaWRpYW4iLCAibGluZSJdCn0K
